<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>excel日常操作记录</title>
    <link href="/2021/01/15/excel%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/01/15/excel%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>虽然不经常用excel做数据筛选操作，但是偶尔还是会有这种需求，每次来都是去科普，没往心里记，这次索性做个记录，以后有什么excel计算的场景直接看自己的案例更清晰。</p></blockquote><h2 id="两个sheet页筛选"><a href="#两个sheet页筛选" class="headerlink" title="两个sheet页筛选"></a>两个sheet页筛选</h2><p>例如有excel表内原始数据（在sheet1内）如下：</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16105907874158.png" srcset="/img/loading.gif" alt=""></p><p>由于某些情况，你将某些发生异常的订单给拉了出来，但是你只知道订单号，这个金额由于特殊原因无法获取，于是把这些异常的订单，新建了sheet2来进行记录，如下：</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16105910278239.png" srcset="/img/loading.gif" alt=""></p><p>现在需要知道每条订单对应的金额应该是多少，可以使用vlookup函数来进行解决。</p><p>在sheet2页内B1列新建一列[金额]，将鼠标放在B2，选择<code>公式-插入函数-选择vlookup</code>：</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1610591251907.png" srcset="/img/loading.gif" alt=""></p><p>解释一下要填写的几个值的描述：</p><ul><li>Lookup_value 选择要基于哪个列去查询，这里选择A2。</li><li>Table_array 选择查询的区域，可以选多个。</li><li>Col_index_num 选择查询区域的第几列。</li><li>Range_lookup 这个主要是说明精确匹配（0）还是模糊匹配（1）</li></ul><p>想要通过sheet2的异常订单号列作为条件，所以<code>Lookup_value设置为A2</code>，因为要从sheet1内查询，所以<code>Table_array设置为Sheet1!A:C</code>，因为金额在我们选中区域内的第三列，所以<code>Col_index_num设置为3</code>，因为要精确匹配，所以<code>Range_lookup设置为0</code>。</p><p>具体设置如下：</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16105918782352.png" srcset="/img/loading.gif" alt=""></p><p>填充后效果如下，姓名列也是按相同的方式进行了设置，</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16105930221551.png" srcset="/img/loading.gif" alt=""></p><h2 id="如何实现快速下拉"><a href="#如何实现快速下拉" class="headerlink" title="如何实现快速下拉"></a>如何实现快速下拉</h2><p>选中公式列，<code>ctrl+shift+end</code>，选中后再公式文本框执行<code>ctrl+enter</code>，即可完成。</p><h1 id="如何对数据分组"><a href="#如何对数据分组" class="headerlink" title="如何对数据分组"></a>如何对数据分组</h1><p>还是上面的例子，筛选出来异常订单的金额、用户姓名之后，如何按用户进行分组，然后得出每个人下的金额呢？</p><p>可以使用数据透视表，在excel内<code>插入-数据透视表</code>，对话框中选中数据区域，</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1610593390592.png" srcset="/img/loading.gif" alt=""></p><p>求和值设置<code>金额</code>列，行标签设置为<code>用户姓名</code>即可搞定。</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16105934885814.png" srcset="/img/loading.gif" alt=""></p><p>如上，搞定，后续有别的需要再来记录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OutOfMemory Error如何排查</title>
    <link href="/2021/01/11/OutOfMemory%20Error%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5/"/>
    <url>/2021/01/11/OutOfMemory%20Error%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p>最近线上项目有开始出现oom类型错误，为了方便下次排查，所以对java项目如何发生oom应该如何处理步骤流程大致梳理一下，方便日后使用。</p><h1 id="如何能快速查看到异常堆栈信息"><a href="#如何能快速查看到异常堆栈信息" class="headerlink" title="如何能快速查看到异常堆栈信息"></a>如何能快速查看到异常堆栈信息</h1><p>任何java项目，在运行过程中可以通过命令来实时获取该项目的堆栈详细数据信息，同时也可以设置在发生<code>OutOfMemory</code>时自动生成dump文件来供我们本地分析问题。</p><h2 id="运行时获取dump文件"><a href="#运行时获取dump文件" class="headerlink" title="运行时获取dump文件"></a>运行时获取dump文件</h2><ul><li><p>首先通过命令行找到当前运行项目在服务器上的pid，也就是进程号，获取方式很多种，如果你是linux系统，可以通过<code>ps -f |grep xxx.jar</code> 来定位，或者通过<code>jps</code>来查看。</p></li><li><p>获取到pid之后，就可以通过<code>jmap</code>命令来进行导出堆文件的导出。示例：</p></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">jmap -<span class="hljs-keyword">dump</span>:<span class="hljs-keyword">file</span>=javaDump.<span class="hljs-keyword">dump</span>,format=b <span class="hljs-number">24552</span><br></code></pre></td></tr></table></figure><p>这样会获取到一个名为javaDump.dump的文件。</p><h2 id="发生oom异常时自动生成dump文件"><a href="#发生oom异常时自动生成dump文件" class="headerlink" title="发生oom异常时自动生成dump文件"></a>发生oom异常时自动生成dump文件</h2><p>这个可以通过jvm启动参数来进行获取。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">-<span class="hljs-string">XX:</span>+HeapDumpOnOutOfMemoryError -<span class="hljs-string">XX:</span>HeapDumpPath=./<br></code></pre></td></tr></table></figure><p>如上，会在发生oom时，将dump文件输出到根目录下。</p><h1 id="如何分析dump文件"><a href="#如何分析dump文件" class="headerlink" title="如何分析dump文件"></a>如何分析dump文件</h1><p>dump文件搞定了，接下来是如何分析呢？如何通过工具或者别的方式来对dump出来的文件进行一个深入解读？</p><h2 id="jhat分析"><a href="#jhat分析" class="headerlink" title="jhat分析"></a>jhat分析</h2><p>jdk中有自带jhat工具来对文件进行在线分析，通过<code>jhat xxx.dump/hprof</code>，之后，本地访问<code>http://localhost:7000</code>，即可在浏览器看到访问效果，如图：</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103487331830.png" srcset="/img/loading.gif" alt="通过jhat启动查看dump"></p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103490572886.png" srcset="/img/loading.gif" alt="jhat页面1"></p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1610349010325.png" srcset="/img/loading.gif" alt="jhat页面2"></p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103492726863.png" srcset="/img/loading.gif" alt="jhat页面3"></p><p>页面大致是长这个样子，重点查看 Other Queries目录下的SHow heap histogram，可以比较容易观察到对象的引用次数及占用内存的大小。</p><p>使用jhat优点是非常方便，通过命令行即可查看视图，缺点是如果文件过大，容易导致浏览器卡崩，而且都是通过纯文本描述，阅览上并不够直观。</p><h2 id="jvisualvm分析"><a href="#jvisualvm分析" class="headerlink" title="jvisualvm分析"></a>jvisualvm分析</h2><p>jdk的另一个工具，visualvm也可以对dump文件进行可视化分析，且功能比较强大，可以定位到具体运行的线程错误（代码行），虽然分析jvm内存是一件非常复杂工作，即使定位到代码行也不一定就是该位置导致的oom，但是和jhat相比，jvisualvm有很大优势。</p><p>找到所在操作系统内的<code>$JAVA_HOME/bin/jvisualvm.exe</code>，双击即可启动，启动后左上角<code>文件-&gt;装入</code>，选择指定的要分析的文件即可。</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103500291910.png" srcset="/img/loading.gif" alt="jvisualvm界面图"></p><p>综合来看还是使用jvisualvm来进行dump文件的查询分析更直观、更利于定位问题。</p><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>本地编写一块测试代码验证一下流程，方便记忆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; ;) &#123;<br>            list.add(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"i am couter this is "</span> + cnt));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写如上代码，且设置一下jvm启动参数：<code>-Xmx20m -Xms20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code>，在IDEA内设置参数非常方便：</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103505327086.png" srcset="/img/loading.gif" alt="IDEA设置jvm启动参数"></p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103507065766.png" srcset="/img/loading.gif" alt="IDEA设置jvm启动参数"></p><p>这里需要注意，在测试时，不要设置-Xms太小，如果太小会在启动时报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error </span>occurred during initialization of VM <br>GC triggered before VM initialization comA1eted. Try increasing NewSize, current value 1536K .<br></code></pre></td></tr></table></figure><p>设置完之后启动main方法，在发生oom之后会自动导出dump文件到当前目录下。</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1610351281678.png" srcset="/img/loading.gif" alt="oom控制台信息"></p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103514014791.png" srcset="/img/loading.gif" alt="oom文件"></p><p>将这个文件通过分析工具来定位查看信息，通过[概要]项可以定位哪个该线程触发了错误信息，且户定位到代码行。</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1610351484622.png" srcset="/img/loading.gif" alt="jvva visual VM page 1"></p><p>通过[类]项可以更清晰的看到对象引用记录。</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103516355191.png" srcset="/img/loading.gif" alt="jvva visual VM page 2"></p><p>可以看到引用最多的是char数组，其实就是string，因为string的底层结构就是char[]，双击char[]进去之后，可以详细看到究竟是谁在引用它。</p><p><img src="https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16103519112087.png" srcset="/img/loading.gif" alt="jvva visual VM page 3"></p><p>可以看到，引用该类实例的是ArrayList持续装载，且可以定位到具体文本内容。</p><h1 id="扩展补充-OutOfMemoryError的几种类型"><a href="#扩展补充-OutOfMemoryError的几种类型" class="headerlink" title="扩展补充 OutOfMemoryError的几种类型"></a>扩展补充 OutOfMemoryError的几种类型</h1><ul><li><p><strong>OutOfMemoryError: GC overhead limit exceeded</strong></p><p>  这是指程序基本耗尽了所有的内存 GC都清理不了，意味着GC占用了大部分CPU周期，大多数意味着98％或99％，并且在每次运行中它释放的内存非常少1-2％对别的线程影响很大影响整个系统吞吐量，比如一个线程占用98%内存无法释放，其他线程执行过程中由于内存限制就会抛出这个错误，甚至会导致连接数据库等这种操作变的缓慢，出现类似一个请求处理好几分钟的现象。</p></li></ul><ul><li><p><strong>OutOfMemoryError: Java heap space</strong></p><p>  相当于将xl型号的东西往只有s号空间内塞的意思，意味着应用程序在某些处理期间内存不足。</p></li></ul><ul><li><p><strong>OutOfMemoryError: Permgen space | OutOfMemoryError: Metaspace</strong></p><p>  在java8之前存在用永久代来实现方法区，这个永久代归堆管理，但是java8之后，将方法区的实现放在元空间，那么方法区内存不足时，在java8之前会出现：permgen space的oom错误，java8之后，也就是方法区通过元空间来实现，这个区域内存不足时会报：Metaspace</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在排查oom问题时，排查步骤如下：</p><ol><li><p>设置jvm启动参数，<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code>，在发生oom时自动生成dump文件。</p></li><li><p>如果是生产服务器，可以将文件发送到本地，通过jvisualvm进行排查。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode40：TOP k，快排算法</title>
    <link href="/2020/04/20/leetcode-topk/"/>
    <url>/2020/04/20/leetcode-topk/</url>
    
    <content type="html"><![CDATA[<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><a id="more"></a><p>此题解法：快排、优先队列、treemap、最大数据范围…</p><p>第四十题，最简单的就是使用冒泡排序，然后直接返回k长度的数组就可以，这个不多说。</p><p>主要记录一下今天在题解中学到的快速排序方法，首先来一个自己后来写的快排示例替代冒泡。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> quickSearch(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)&#123;<br>        <span class="hljs-keyword">if</span> (lo &gt; hi) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> start = lo;<br>        <span class="hljs-type">int</span> end = hi + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> v = arr[lo];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-comment">--end &gt;= lo &amp;&amp; arr[end] &gt; v);</span><br>            <span class="hljs-keyword">while</span> (++<span class="hljs-keyword">start</span> &lt;= hi &amp;&amp; arr[<span class="hljs-keyword">start</span>] &lt; v);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">start</span> &gt;= <span class="hljs-keyword">end</span>)&#123;<br>                break;<br>            &#125;<br>            <span class="hljs-type">int</span> t = arr[<span class="hljs-keyword">end</span>];<br>            arr[<span class="hljs-keyword">end</span>] = arr[<span class="hljs-keyword">start</span>];<br>            arr[<span class="hljs-keyword">start</span>] = t;<br>        &#125;<br><br>        arr[lo] = arr[<span class="hljs-keyword">end</span>];<br>        arr[<span class="hljs-keyword">end</span>] = v;<br>        <br>        quickSearch(arr, lo, <span class="hljs-keyword">end</span> - <span class="hljs-number">1</span>);<br>        quickSearch(arr, <span class="hljs-keyword">end</span> + <span class="hljs-number">1</span>, hi);<br>    &#125;<br></code></pre></td></tr></table></figure><p>和冒泡排序相比，冒泡时间复杂度O(n^2^)，快排时间复杂度为O(nlog2n)，如何用快排实现本题呢？上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution4</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>     * 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br>     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span> ||  arr.length &lt; k)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> k)&#123;<br>        <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的</span><br>        <span class="hljs-keyword">int</span> j = quickSort(arr, lo, hi);<br>        <span class="hljs-keyword">if</span>(j == k) &#123;<br>            <span class="hljs-keyword">return</span> Arrays.copyOf(arr, j + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span><br>        <span class="hljs-keyword">return</span> j &gt; k ? sort(arr, lo, j - <span class="hljs-number">1</span>, k) : sort(arr, j + <span class="hljs-number">1</span>, hi, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = lo;<br>        <span class="hljs-keyword">int</span> j = hi + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 假设临界的值</span><br>        <span class="hljs-keyword">int</span> v = arr[lo];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(--j &gt;= lo &amp;&amp; arr[j] &gt; v);<br>            <span class="hljs-keyword">while</span>(++i &lt;= hi &amp;&amp; arr[i] &lt; v);<br>            <span class="hljs-keyword">if</span>(i &gt;= j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> temp = arr[j];<br>            arr[j] = arr[i];<br>            arr[i] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 将临界值和j所在位置进行替换</span><br>        arr[lo] = arr[j];<br>        arr[j] = v;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br></code></pre></td></tr></table></figure><p>提交后效率占比还是非常可观的：</p><p><img src="https://uacoding.cn/images/posts/leetcode/topk.png" srcset="/img/loading.gif" alt="运行效率图"></p><p>至此，快排完美完成，解释都在代码内，日后自己不懂再来光顾。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot中由于配置不当导致jedis连接报错</title>
    <link href="/2020/04/09/springboot-redis-setting/"/>
    <url>/2020/04/09/springboot-redis-setting/</url>
    
    <content type="html"><![CDATA[<blockquote><p>生产近期出现redis服务异常的问题，今天抽时间对该问题进行解决。</p></blockquote><a id="more"></a><h2 id="异常复现"><a href="#异常复现" class="headerlink" title="异常复现"></a>异常复现</h2><p>先贴出报错信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent.CompletionException: org.springframework.data.redis.RedisConnectionFailureException: Cannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: connect timed out<br>        at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:<span class="hljs-number">273</span>)<br>        at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:<span class="hljs-number">280</span>)<br>        at java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:<span class="hljs-number">1629</span>)<br>        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1142</span>)<br>        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">617</span>)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br>Caused by: org.springframework.data.redis.RedisConnectionFailureException: Cannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: connect timed out<br>        at org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector(JedisConnectionFactory.java:<span class="hljs-number">286</span>)<br>        at org.springframework.data.redis.connection.jedis.JedisConnectionFactory.getConnection(JedisConnectionFactory.java:<span class="hljs-number">469</span>)<br>        at org.springframework.data.redis.core.RedisConnectionUtils.doGetConnection(RedisConnectionUtils.java:<span class="hljs-number">132</span>)<br>        at org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:<span class="hljs-number">95</span>)<br>        at org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:<span class="hljs-number">82</span>)<br>        at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:<span class="hljs-number">211</span>)<br>        at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:<span class="hljs-number">184</span>)<br>        at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:<span class="hljs-number">95</span>)<br>        at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:<span class="hljs-number">48</span>)<br>        at com.haohuo.util.RedisUtils.get(RedisUtils.java:<span class="hljs-number">176</span>)<br>        at com.haohuo.compose.PayOutCompose.lambda$asyncPay$<span class="hljs-number">1</span>(PayOutCompose.java:<span class="hljs-number">949</span>)<br>        at java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:<span class="hljs-number">1626</span>)<br>        ... <span class="hljs-number">3</span> common frames omitted<br>Caused by: redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: connect timed out<br>        at redis.clients.jedis.Connection.connect(Connection.java:<span class="hljs-number">207</span>)<br>        at redis.clients.jedis.BinaryClient.connect(BinaryClient.java:<span class="hljs-number">93</span>)<br>        at redis.clients.jedis.BinaryJedis.connect(BinaryJedis.java:<span class="hljs-number">1767</span>)<br>        at org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector(JedisConnectionFactory.java:<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>由于项目中redis是使用阿里云redis，所以上阿里云查询相关解释：</p><p><img src="https://uacoding.cn/images/blog/aliredis-errormsg.jpg" srcset="/img/loading.gif" alt="image"></p><p>结合该报错信息非常明显，连接超时，那么顺着思路解决超时的问题就可以了，接着找到项目中关于redis的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.redis.host=<span class="hljs-number">192.168</span><span class="hljs-number">.11</span><span class="hljs-number">.231</span><br>spring.redis.port=<span class="hljs-number">6379</span><br>spring.redis.password=<br>spring.redis.lettuce.pool.max-active=-<span class="hljs-number">1</span><br>spring.redis.lettuce.pool.max-idle=<span class="hljs-number">100</span><br>spring.redis.lettuce.pool.max-wait=-<span class="hljs-number">1</span>ms<br>spring.redis.lettuce.pool.min-idle=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>从这边来看的话，<code>spring.redis.lettuce.pool.max-wait=-1ms</code>这种负数的配置给出现在springboot中，第一印象就是没有限制的意思，但是这从报错信息上来看是完全解释不通，相矛盾的，当然这段配置是<code>前辈们</code>留下来的，也在生产跑的没有出过什么大问题，那到底是为什么呢？</p><p>带着这个疑问，那么只能在本地模拟一下并发来看是否可以复现一样的异常信息，模拟接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedisUtils redisUtils;<br><br>  <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"test"</span>, method = RequestMethod.GET)<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ComResult <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>&#123;<br>      redisUtils.set(<span class="hljs-string">"zhangpk.test"</span>, <span class="hljs-string">"countdownexcep"</span>, <span class="hljs-number">60</span> *<span class="hljs-number">60</span>);<br>      ExecutorService pool = Executors.newCachedThreadPool();<br>      CountDownLatch cdl = <span class="hljs-keyword">new</span> CountDownLatch(count);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br>          pool.execute(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">/*** 不加锁也可以支持*/</span><br>                  <span class="hljs-keyword">synchronized</span> (cdl) &#123;<br>                      <span class="hljs-comment">/*** 每次减少一个容量*/</span><br>                      cdl.countDown();<br>                  &#125;<br>                  <span class="hljs-comment">/*** 阻塞线程，直到countDown至0*/</span><br>                  cdl.await();<br>                  System.out.println(redisUtils.get(<span class="hljs-string">"zhangpk.test"</span>));<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>              &#125;<br>          &#125;);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> success(<span class="hljs-string">""</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以入参直接调用我们吧count值从100逐渐往上加，发现count=500后会偶尔出现上述异常，1000后比较频繁，这样看来生产出问题是理所应当的呀，因为某些服务的使用并发是绝对有的。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>当前项目使用的springboot版本是2.x，从网上随便一查都可以了解到，1.x和2.x在使用redis连接池的默认值是不一样的，1.x默认使用<code>jedis</code>连接池，2.x默认使用的是<code>lettuce</code>，我们项目很明显这里配置是针对<code>lettuce</code>连接池的，这里配置如果没问题的话，那是不是说在注入bean实例时出现问题了呢？顺着这个思路，找到项目中redistemplate这个bean，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"redisTemplate"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span><span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;Object, Object&gt;();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        template.setStringSerializer(stringRedisSerializer);<br>        template.setKeySerializer(stringRedisSerializer);<br>        template.setHashKeySerializer(stringRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这段代码就是一个配置，支持更好的序列化方式，使用了<code>RedisConnectionFactory</code>工厂，当前接口获取连接的实现类有两个，就是上面提到的两种连接池，源码也比较清晰；但是这里并没有找到对当前工厂进行单独设置的bean，这里有一个疑问，就是说lettuce在配置后会自动配置到<code>RedisConnectionFactory</code>内吗？</p><p>带着这个疑问，开始debug该bean方法，发现<code>RedisConnectionFactory</code>在项目初始化时构造如下图：<br><img src="https://uacoding.cn/images/blog/redisfactory.png" srcset="/img/loading.gif" alt="image"></p><p>很明显没有lettuce的任何信息呀，这。。。</p><p>然后去科普了一些springboot集成lettuce连接redis的案例，详细不在此赘述了，总之最后得出结论：当前redis配置绝对有问题！</p><p>由于当前项目内使用分布式锁是通过jedis来实现的，所以更倾向于将连接池直接改为jedis，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"># redis参数<br>spring.redis.host=192.168.11.231<br>spring.redis.port=6379<br>spring.redis.password=<br>spring.redis.jedis.pool.max-active=50<br>spring.redis.jedis.pool.max-idle=50<br>spring.redis.jedis.pool.max-wait=3s<br>spring.redis.jedis.pool.min-idle=10<br></code></pre></td></tr></table></figure><p>经过多次验证<code>spring.redis.jedis.pool.max-active=-1</code>是绝对要设置指定值的，给一个适合的值能保证在项目初始化时创建出这些连接数，从而提高资源利用率，这个和druid连接mysql数据库同样的道理；同时<code>spring.redis.jedis.pool.max-wait=3s</code>当前设置为3s，是因为当前项目使用dubbo来实现分布式服务之间的通信，dubbo的线程数是有限且是有超时时间的，为了防止由于redis造成的服务阻塞、宕机，该值还是设置的合理一些比较好，这段配置后，在本地运行一下测试方法，是可以让当前单机redis达到万级的，没有任何异常，后续如果项目发生问题再更新。</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode1160：拼接单词</title>
    <link href="/2020/03/19/spell-word/"/>
    <url>/2020/03/19/spell-word/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。<br>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。<br>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。<br>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lsl">输入：words = [<span class="hljs-string">"cat"</span>,<span class="hljs-string">"bt"</span>,<span class="hljs-string">"hat"</span>,<span class="hljs-string">"tree"</span>], chars = <span class="hljs-string">"atach"</span><br>输出：<span class="hljs-number">6</span><br>解释： <br>可以形成字符串 <span class="hljs-string">"cat"</span> 和 <span class="hljs-string">"hat"</span>，所以答案是 <span class="hljs-number">3</span> + <span class="hljs-number">3</span> = <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lsl">输入：words = [<span class="hljs-string">"hello"</span>,<span class="hljs-string">"world"</span>,<span class="hljs-string">"leetcode"</span>], chars = <span class="hljs-string">"welldonehoneyr"</span><br>输出：<span class="hljs-number">10</span><br>解释：<br>可以形成字符串 <span class="hljs-string">"hello"</span> 和 <span class="hljs-string">"world"</span>，所以答案是 <span class="hljs-number">5</span> + <span class="hljs-number">5</span> = <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>1.1 &lt;= words.length &lt;= 1000<br>2.1 &lt;= words[i].length, chars.length &lt;= 100<br>3.所有字符串中都仅包含小写英文字母  </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>说下让我看起来非常惊艳的解法，通过26位ASCII编码属性计算每个字母的count数量，然后通过<code>words</code>循环内的元素和<code>chars</code>数组进行对比，最后return满足条件的长度就好了，废话不多说，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>    * <br>    * <span class="hljs-doctag">@param</span> words<br>    *          单词数组<br>    * <span class="hljs-doctag">@param</span> chars<br>    *          已有字母<br>    * <span class="hljs-doctag">@return</span><br>    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countCharacters</span><span class="hljs-params">(String[] words, String chars)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span>[] originalCounter = counter(chars);<br>       <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>           String word = words[i];<br>           <span class="hljs-keyword">int</span>[] wordCounter = counter(word);<br>           <span class="hljs-keyword">boolean</span> isSuccess = <span class="hljs-keyword">true</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>               <span class="hljs-keyword">if</span> (originalCounter[j] &lt; wordCounter[j]) &#123;<br>                   isSuccess = <span class="hljs-keyword">false</span>;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>               length += word.length();<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> length;<br>   &#125;<br><br>   <span class="hljs-comment">/**<br>    * 将字符转为索引对应的ASCII码值<br>    * <br>    * <span class="hljs-doctag">@param</span> word<br>    * <span class="hljs-doctag">@return</span><br>    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] counter(String word)&#123;<br>       <span class="hljs-keyword">int</span>[] counter = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>       <span class="hljs-keyword">char</span>[] charArray = word.toCharArray();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; charArray.length; j++) &#123;<br>           counter[charArray[j] - <span class="hljs-string">'a'</span>] ++; <span class="hljs-comment">// 这里是关键哦</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> counter;<br>   &#125;<br></code></pre></td></tr></table></figure><p>思路还是挺好的，但是上面的代码有些冗余有没有发现，正好通过这次刷题，学到了<code>continue 标签;</code>这种写法，意义在于使内层循环break，外层继续下次遍历，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countCharacters</span><span class="hljs-params">(String[] words, String chars)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] ch_array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars.toCharArray()) &#123;<br>            ++ch_array[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        search:<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-keyword">int</span>[] word_count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (++word_count[c - <span class="hljs-string">'a'</span>] &gt; ch_array[c - <span class="hljs-string">'a'</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span> search;<br>                &#125;<br>            &#125;<br>            length += word.length();<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode169：多数元素</title>
    <link href="/2020/03/13/most-of-element/"/>
    <url>/2020/03/13/most-of-element/</url>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><a id="more"></a><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>这直接分组得到数组内每个数值对应的count数值，过滤得出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = nums.length / <span class="hljs-number">2</span>;<br>        List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(Integer::intValue));<br>        List&lt;Integer&gt; retList = collect.keySet().stream().filter(key -&gt; collect.get(key).size() &gt; count).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> retList == <span class="hljs-keyword">null</span> || retList.isEmpty() ? <span class="hljs-number">0</span> : retList.get(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遗憾的是，效率忒低了，当我吧这条记录提交后，显示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">执行用时 :<span class="hljs-number">32</span> ms, 在所有 Java 提交中击败了<span class="hljs-number">9.90</span>%的用户<br><br>内存消耗 :<span class="hljs-number">44.2</span> MB, 在所有 Java 提交中击败了<span class="hljs-number">5.07</span>%的用户<br></code></pre></td></tr></table></figure><p>难受啊，一下子感觉自尊心受到了一点点侮辱，两个百分比都没过两位数，当然通过题库官方解读，还是可以写出来剩下的几种方法和理解。</p><h3 id="排序算法实现"><a href="#排序算法实现" class="headerlink" title="排序算法实现"></a>排序算法实现</h3><p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为⌊<code>\frac{n}{2}</code> ⌋ 的元素（下标从 0 开始）一定是众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code>。将数组排序的时间复杂度为 <code>O(nlogn)</code>。</li><li>空间复杂度：<code>O(logn)</code>。如果使用语言自带的排序算法，需要使用 <code>O(logn)</code> 的栈空间。如果自己编写堆排序，则只需要使用 <code>O(1)O(1)</code> 的额外空间。</li><li><h3 id="hash实现"><a href="#hash实现" class="headerlink" title="hash实现"></a>hash实现</h3></li></ul><p>出现次数最多的元素大于 ⌊<code>$\frac{n}{2}$</code>⌋ 次，所以可以用哈希表来快速统计每个元素出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        Integer count = map.get(num);<br>        map.put(num, count == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : ++count);<br>    &#125;<br><br>    Map.Entry&lt;Integer, Integer&gt; majEntry = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (majEntry == <span class="hljs-keyword">null</span> || entry.getValue() &gt; majEntry.getValue()) &#123;<br>            majEntry = entry;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> majEntry.getKey();<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h3 id="投票算法"><a href="#投票算法" class="headerlink" title="投票算法"></a>投票算法</h3><p>如果把众数记为 +1，把其他数记为−1，将它们全部加起来，显然和大于0，从结果本身可以看出众数比其他数多。</p><p>可能不太好理解，<a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/" target="_blank" rel="noopener">点击此处带你飞</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maj = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            maj = nums[i];<br>        &#125;<br>        count += (maj == nums[i]) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maj;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</li><li>空间复杂度：O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法的时间与空间复杂度介绍</title>
    <link href="/2020/03/01/2019-10-15-java-algorithm/"/>
    <url>/2020/03/01/2019-10-15-java-algorithm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p></blockquote><a id="more"></a><p>那么我们应该如何去衡量不同算法之间的优劣呢？</p><p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li></ul><p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p><p>下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。</p><p>这种方式可以吗？当然可以，不过它也有很多弊端。<br>这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。</p><p>因此，另一种更为通用的方法就出来了：「 大O符号表示法 」，即 T(n) = O(f(n))</p><p>我们先来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br>&#123;<br>   j = i;<br>   j++;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?</p><p>在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p><p>我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)</p><p>为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p><p>所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。</p><p>常见的时间复杂度量级有：</p><ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)</li></ul><p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p><p>下面选取一些较为常用的来讲解一下（没有严格按照顺序）：</p><h3 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;<br>++i;<br>j++;<br><span class="hljs-keyword">int</span> m = i + j;<br></code></pre></td></tr></table></figure><p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p><h3 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h3><p>这个在最开始的代码示例中就讲解过了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br>&#123;<br>   j = i;<br>   j++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。</p><h3 id="对数阶O-logN"><a href="#对数阶O-logN" class="headerlink" title="对数阶O(logN)"></a>对数阶O(logN)</h3><p>还是先来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;n)<br>&#123;<br>    i = i * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br>也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：<strong>O(logn)</strong></p><h3 id="线性对数阶O-nlogN"><a href="#线性对数阶O-nlogN" class="headerlink" title="线性对数阶O(nlogN)"></a>线性对数阶O(nlogN)</h3><p>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。</p><p>就拿上面的代码加一点修改来举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(m=<span class="hljs-number">1</span>; m&lt;n; m++)<br>&#123;<br>    i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n)<br>    &#123;<br>        i = i * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="平方阶O-n²"><a href="#平方阶O-n²" class="headerlink" title="平方阶O(n²)"></a>平方阶O(n²)</h3><p>平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>; i&lt;=n; x++)<br>&#123;<br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>       j = i;<br>       j++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)<br>如果将其中一层循环的n改成m，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>; i&lt;=m; x++)<br>&#123;<br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>       j = i;<br>       j++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那它的时间复杂度就变成了 O(m*n)</p><p>立方阶O(n³)、K次方阶O(n^k)<br>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。</p><p>除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。</p><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：</p><h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O(1)"></a>空间复杂度 O(1)</h3><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;<br>++i;<br>j++;<br><span class="hljs-keyword">int</span> m = i + j;<br></code></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h3 id="空间复杂度-O-n"><a href="#空间复杂度-O-n" class="headerlink" title="空间复杂度 O(n)"></a>空间复杂度 O(n)</h3><p>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。<br>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地&quot;进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。</p><p>如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。</p><p>我们看一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] m = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i)<br>&#123;<br>   j = i;<br>   j++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><p>依次类推和时间复杂度表示大同小异了各位。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">https://blog.csdn.net/zolalad/article/details/11848739</a></p><p><a href="https://zhuanlan.zhihu.com/p/50479555" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50479555</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized关键字详解</title>
    <link href="/2020/03/01/2019-09-24-face-synchronized/"/>
    <url>/2020/03/01/2019-09-24-face-synchronized/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说实话，本来没计划单独出来一篇synchronized的笔记的，但是当我将synchronized的简单介绍放到多线程相关知识谱这篇之后，在csdn内发现了一个真的不错的好文，顾摘抄来闲时多品味</p></blockquote><a id="more"></a><h2 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h2><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h2 id="synchronized作用于实例方法"><a href="#synchronized作用于实例方法" class="headerlink" title="synchronized作用于实例方法"></a>synchronized作用于实例方法</h2><p>所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountingSync</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">//共享资源(临界资源)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**<br>     * synchronized 修饰实例方法<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br>            increase();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        AccountingSync instance=<span class="hljs-keyword">new</span> AccountingSync();<br>        Thread t1=<span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2=<span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-comment">/**<br>     * 输出结果:<br>     * 2000000<br>     */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们开启两个线程操作同一个共享资源即变量i，由于i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。此时我们应该注意到synchronized修饰的是实例方法increase，在这样的情况下，当前线程的锁便是实例对象instance，注意Java中的线程同步锁可以是任意对象。从代码执行结果来看确实是正确的，倘若我们没有使用synchronized关键字，其最终输出结果就很可能小于2000000，这便是synchronized关键字的作用。这里我们还需要意识到，当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时==如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了==，如下代码将演示出该现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountingSyncBad</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br>            increase();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//new新实例</span><br>        Thread t1=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> AccountingSyncBad());<br>        <span class="hljs-comment">//new新实例</span><br>        Thread t2=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> AccountingSyncBad());<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">//join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span><br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是<font color=red>1452317</font>而不是期望结果<font color=red>2000000</font>，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。解决这种困境的的方式是将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法。</p><h2 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h2><p>当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountingSyncClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**<br>     * 作用于静态方法,锁是当前class对象,也就是<br>     * AccountingSyncClass类对应的class对象<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 非静态,访问时锁不一样不会发生互斥<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase4Obj</span><span class="hljs-params">()</span></span>&#123;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br>            increase();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//new新实例</span><br>        Thread t1=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> AccountingSyncClass());<br>        <span class="hljs-comment">//new心事了</span><br>        Thread t2=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> AccountingSyncClass());<br>        <span class="hljs-comment">//启动线程</span><br>        t1.start();t2.start();<br><br>        t1.join();t2.join();<br>        System.out.println(i);<br>    &#125;<span class="hljs-comment">// 调用increase输出结果 2000000</span><br>    <span class="hljs-comment">// 调用increase4Obj输出结果很可能小于 2000000</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。==</p><h2 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h2><p>除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountingSync</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> AccountingSync instance=<span class="hljs-keyword">new</span> AccountingSync();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//省略其他耗时操作....</span><br>        <span class="hljs-comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span><br>        <span class="hljs-keyword">synchronized</span>(instance)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br>                    i++;<br>              &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1=<span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2=<span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();t2.start();<br>        t1.join();t2.join();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//this,当前实例对象锁</span><br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br>        i++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//class对象锁</span><br><span class="hljs-keyword">synchronized</span>(AccountingSync<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="synchronized底层语义原理"><a href="#synchronized底层语义原理" class="headerlink" title="synchronized底层语义原理"></a>synchronized底层语义原理</h2><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。</p><h3 id="理解Java对象头与Monitor"><a href="#理解Java对象头与Monitor" class="headerlink" title="理解Java对象头与Monitor"></a>理解Java对象头与Monitor</h3><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下：</p><p><img src="https://img-blog.csdn.net/20170603163237166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="image"></p><ul><li><p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p></li><li><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可</p></li></ul><p>而对于顶部，则是Java头对象，它实现synchronized的锁对象的基础，这点我们重点分析它，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表：</p><table><thead><tr><th>虚拟机位数</th><th>头对象结构</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</td></tr></tbody></table><p>其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit</th><th>锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td><td></td></tr></tbody></table><p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：</p><p><img src="https://img-blog.csdn.net/20170603172215966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="image"></p><p>其中轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>    _header       = NULL;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录个数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;<br>    _object       = NULL;<br>    _owner        = NULL;<br>    _WaitSet      = NULL; <span class="hljs-comment">//处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = NULL ;<br>    _succ         = NULL ;<br>    _cxq          = NULL ;<br>    FreeNext      = NULL ;<br>    _EntryList    = NULL ; <span class="hljs-comment">//处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="https://img-blog.csdn.net/20170604114223462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="image"></p><p>由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。</p><h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a>synchronized代码块底层原理</h3><p>现在我们重新定义一个synchronized修饰的同步代码块，在代码块中操作共享变量i，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncCodeBlock</span> </span>&#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncTask</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-comment">//同步代码库</span><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>)&#123;<br>           i++;<br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译上述代码并使用javap -c -v反编译后得到字节码如下(这里我们省略一部分没有必要的信息)：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /D:/idea_space/mycloud_one/thread/learn/src/main/java/code2/code2/SyncCodeBlock.class<br>  Last modified 2019-9-24; size 408 bytes<br>  MD5 checksum c8f2c4f13a88642b6607cd03ce8cdee7<br>  Compiled from "SyncCodeBlock.java"<br>public class code2.SyncCodeBlock<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>  //........省略常量池中数据<br>  //构造函数<br>  public code2.SyncCodeBlock();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>         4: return<br>      LineNumberTable:<br>        line 7: 0<br>  //===========主要看看syncTask方法实现================<br>  public void syncTask();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=3, locals=3, args_size=1<br>         0: aload_0<br>         1: dup<br>         2: astore_1<br>         3: monitorenter  //注意此处，进入同步方法<br>         4: aload_0<br>         5: dup<br>         6: getfield      #2             // Field i:I<br>         9: iconst_1<br>        10: iadd<br>        11: putfield      #2            // Field i:I<br>        14: aload_1<br>        15: monitorexit   //注意此处，退出同步方法<br>        16: goto          24<br>        19: astore_2<br>        20: aload_1<br>        21: monitorexit //注意此处，退出同步方法<br>        22: aload_2<br>        23: athrow<br>        24: return<br>      Exception table:<br>      //省略其他字节码.......<br>&#125;<br>SourceFile: "SyncCodeBlock.java"<br></code></pre></td></tr></table></figure><p>我们主要关注字节码中的如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>: monitorenter  <span class="hljs-comment">//进入同步方法</span><br><span class="hljs-comment">//..........省略其他  </span><br><span class="hljs-number">15</span>: monitorexit   <span class="hljs-comment">//退出同步方法</span><br><span class="hljs-number">16</span>: goto          <span class="hljs-number">24</span><br><span class="hljs-comment">//省略其他.......</span><br><span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">//退出同步方法</span><br></code></pre></td></tr></table></figure><p>从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，==当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。==从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><h3 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a>synchronized方法底层原理</h3><p>==方法级的同步是隐式==，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncMethod</span> </span>&#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncTask</span><span class="hljs-params">()</span></span>&#123;<br>           i++;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用javap反编译后的字节码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /D:/idea_space/mycloud_one/thread/learn/src/main/java/code2/code2/SyncMethod.class<br>  Last modified 2019-9-24; size 290 bytes<br>  MD5 checksum 8a27c61566f24a394bdf2b7fcbc0acf6<br>  Compiled from "SyncMethod.java"<br>public class code2.SyncMethod<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool;<br><br>   //省略没必要的字节码<br>  //==================syncTask方法======================<br>  public synchronized void syncTask();<br>    descriptor: ()V<br>    //方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法<br>    flags: ACC_PUBLIC, ACC_SYNCHRONIZED<br>    Code:<br>      stack=3, locals=1, args_size=1<br>         0: aload_0<br>         1: dup<br>         2: getfield      #2                  // Field i:I<br>         5: iconst_1<br>         6: iadd<br>         7: putfield      #2                  // Field i:I<br>        10: return<br>      LineNumberTable:<br>        line 12: 0<br>        line 13: 10<br>&#125;<br>SourceFile: "SyncMethod.java"<br></code></pre></td></tr></table></figure><p>从字节码中可以看出，s==ynchronized修饰的方法并没有monitorenter指令和monitorexit指令==，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是==在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了==，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。</p><h3 id="Java虚拟机对synchronized的优化"><a href="#Java虚拟机对synchronized的优化" class="headerlink" title="Java虚拟机对synchronized的优化"></a>Java虚拟机对synchronized的优化</h3><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Created by zejian on 2017/6/4.<br> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]<br> * 消除StringBuffer同步锁<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBufferRemoveSync</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>        <span class="hljs-comment">//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用</span><br>        <span class="hljs-comment">//因此sb属于不可能共享的资源,JVM会自动消除内部的锁</span><br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        sb.append(str1).append(str2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBufferRemoveSync rmsync = <span class="hljs-keyword">new</span> StringBufferRemoveSync();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>            rmsync.add(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"123"</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于synchronized-可能需要了解的关键点"><a href="#关于synchronized-可能需要了解的关键点" class="headerlink" title="关于synchronized 可能需要了解的关键点"></a>关于synchronized 可能需要了解的关键点</h2><h3 id="synchronized的可重入性"><a href="#synchronized的可重入性" class="headerlink" title="synchronized的可重入性"></a>synchronized的可重入性</h3><p>从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountingSync</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> AccountingSync instance=<span class="hljs-keyword">new</span> AccountingSync();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000000</span>;j++)&#123;<br><br>            <span class="hljs-comment">//this,当前实例对象锁</span><br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>                i++;<br>                increase();<span class="hljs-comment">//synchronized的可重入性</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br>        j++;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1=<span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2=<span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();t2.start();<br>        t1.join();t2.join();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，==需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1==。</p><h3 id="线程中断与synchronized"><a href="#线程中断与synchronized" class="headerlink" title="线程中断与synchronized"></a>线程中断与synchronized</h3><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//中断线程（实例方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Thread.interrupt();<br><br><span class="hljs-comment">//判断线程是否被中断（实例方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> Thread.isInterrupted();<br><br><span class="hljs-comment">//判断是否被中断并清除当前中断状态（静态方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> Thread.interrupted();<br></code></pre></td></tr></table></figure><p>当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruputSleepThread3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//while在try中，通过异常中断就可以退出run循环</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                        <span class="hljs-comment">//当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出</span><br>                        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">"Interruted When Sleep"</span>);<br>                    <span class="hljs-keyword">boolean</span> interrupt = <span class="hljs-keyword">this</span>.isInterrupted();<br>                    <span class="hljs-comment">//中断状态被复位</span><br>                    System.out.println(<span class="hljs-string">"interrupt:"</span>+interrupt);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//中断处于阻塞状态的线程</span><br>        t1.interrupt();<br><br>        <span class="hljs-comment">/**<br>         * 输出结果:<br>           Interruted When Sleep<br>           interrupt:false<br>         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码所示，我们创建一个线程，并在线程中调用了sleep方法从而使用线程进入阻塞状态，启动线程后，调用线程实例对象的interrupt方法中断阻塞异常，并抛出InterruptedException异常，此时中断状态也将被复位。这里有些人可能会诧异，为什么不用Thread.sleep(2000);而是用TimeUnit.SECONDS.sleep(2);其实原因很简单，前者使用时并没有明确的单位说明，而后者非常明确表达秒的单位，事实上后者的内部实现最终还是调用了Thread.sleep(2000);，但为了编写的代码语义更清晰，建议使用TimeUnit.SECONDS.sleep(2);的方式，注意TimeUnit是个枚举类型。ok~，除了阻塞中断的情景，我们还可能会遇到处于运行期且非阻塞的状态的线程，这种情况下，直接调用Thread.interrupt()中断线程是不会得到任响应的，如下代码，将无法中断非阻塞状态下的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruputThread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1=<span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>                    System.out.println(<span class="hljs-string">"未被中断"</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t1.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        t1.interrupt();<br><br>        <span class="hljs-comment">/**<br>         * 输出结果(无限执行):<br>             未被中断<br>             未被中断<br>             未被中断<br>             ......<br>         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然我们调用了interrupt方法，但线程t1并未被中断，因为处于非阻塞状态的线程需要我们手动进行中断检测并结束程序，改进后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruputThread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1=<span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>                    <span class="hljs-comment">//判断当前线程是否被中断</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInterrupted())&#123;<br>                        System.out.println(<span class="hljs-string">"线程中断"</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>                System.out.println(<span class="hljs-string">"已跳出循环,线程中断!"</span>);<br>            &#125;<br>        &#125;;<br>        t1.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        t1.interrupt();<br><br>        <span class="hljs-comment">/**<br>         * 输出结果:<br>            线程中断<br>            已跳出循环,线程中断!<br>         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是的，我们在代码中使用了实例方法isInterrupted判断线程是否已被中断，如果被中断将跳出循环以此结束线程,注意非阻塞状态调用interrupt()并不会导致中断状态重置。综合所述，可以简单总结一下中断两种情况，一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将中断状态复位，另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(其实就是结束run方法体的代码)。有时我们在编码时可能需要兼顾以上两种情况，那么就可以如下编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位</span><br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中断与synchronized"><a href="#中断与synchronized" class="headerlink" title="中断与synchronized"></a>中断与synchronized</h4><p>事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。演示代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedBlocked</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Trying to call f()"</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) <span class="hljs-comment">// Never releases lock</span><br>            Thread.yield();<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 在构造器中创建新线程并启动获取对象锁<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronizedBlocked</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//该线程已持有当前实例锁</span><br>        <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                f(); <span class="hljs-comment">// Lock acquired by this thread</span><br>            &#125;<br>        &#125;.start();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//中断判断</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                System.out.println(<span class="hljs-string">"中断线程!!"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        SynchronizedBlocked sync = <span class="hljs-keyword">new</span> SynchronizedBlocked();<br>        Thread t = <span class="hljs-keyword">new</span> Thread(sync);<br>        <span class="hljs-comment">//启动后调用f()方法,无法获取当前实例锁处于等待状态</span><br>        t.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//中断线程,无法生效</span><br>        t.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在SynchronizedBlocked构造函数中创建一个新线程并启动获取调用f()获取到当前实例锁，由于SynchronizedBlocked自身也是线程，启动后在其run方法中也调用了f()，但由于对象锁被其他线程占用，导致t线程只能等到锁，此时我们调用了t.interrupt();但并不能中断线程。</p><h3 id="等待唤醒机制与synchronized"><a href="#等待唤醒机制与synchronized" class="headerlink" title="等待唤醒机制与synchronized"></a>等待唤醒机制与synchronized</h3><p>所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.wait();<br>       obj.notify();<br>       obj.notifyAll();         <br> &#125;<br></code></pre></td></tr></table></figure><p>需要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BeanFactory和ApplicationContext的区别</title>
    <link href="/2020/03/01/2019-07-01-context/"/>
    <url>/2020/03/01/2019-07-01-context/</url>
    
    <content type="html"><![CDATA[<blockquote><p>接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同</p></blockquote><a id="more"></a><p>我看到过很多问 BeanFactory 和 ApplicationContext 不同点的问题，考虑到这，我应该使用前者还是后者从 Spring 容器中获取 beans 呢？请向下看</p><h2 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean"></a>什么是 Spring Bean</h2><p>这是一个非常简单而又很复杂的问题，通常来说，Spring beans 就是被 Spring 容器所管理的 Java 对象，来看一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zoltanraffai;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123; <br>   <span class="hljs-keyword">private</span> String message;  <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessage</span><span class="hljs-params">(String message)</span></span>&#123; <br>      <span class="hljs-keyword">this</span>.message  = message; <br>   &#125;  <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMessage</span><span class="hljs-params">()</span></span>&#123; <br>      System.out.println(<span class="hljs-string">"My Message : "</span> + message); <br>   &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在基于 XML 的配置中， beans.xml 为 Spring 容器管理 bean 提供元数据</p><h2 id="什么是-Spring-容器"><a href="#什么是-Spring-容器" class="headerlink" title="什么是 Spring 容器"></a>什么是 Spring 容器</h2><p>Spring 容器负责实例化，配置和装配 Spring beans，下面来看如何为 IoC 容器配置我们的 HelloWorld POJO</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span> = <span class="hljs-string">"http://www.springframework.org/schema/beans"</span><br>   <span class="hljs-attr">xmlns:xsi</span> = <span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span><br>   <span class="hljs-attr">xsi:schemaLocation</span> = <span class="hljs-string">"http://www.springframework.org/schema/beans<br>   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">"helloWorld"</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"com.zoltanraffai.HelloWorld"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span> = <span class="hljs-string">"message"</span> <span class="hljs-attr">value</span> = <span class="hljs-string">"Hello World!"</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，它已经被 Spring 容器管理了，接下来的问题是：我们怎样获取它？</p><h1 id="BeanFactory-和-ApplicationContext-的不同点"><a href="#BeanFactory-和-ApplicationContext-的不同点" class="headerlink" title="BeanFactory 和 ApplicationContext 的不同点"></a>BeanFactory 和 ApplicationContext 的不同点</h1><h2 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h2><p>这是一个用来访问 Spring 容器的 root 接口，要访问 Spring 容器，我们将使用 Spring 依赖注入功能，使用 BeanFactory 接口和它的子接口</p><p>特性:</p><ul><li>Bean 的实例化/串联</li></ul><p>通常情况，BeanFactory 的实现是使用懒加载的方式，这意味着 beans 只有在我们通过 getBean() 方法直接调用它们时才进行实例化</p><p>实现 BeanFactory 最常用的 API 是 XMLBeanFactory</p><p>这里是如何通过 BeanFactory 获取一个 bean 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zoltanraffai;  <br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;  <br><span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean; <br><span class="hljs-keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldApp</span></span>&#123; <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>      XmlBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory (<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>)); <br>      HelloWorld obj = (HelloWorld) factory.getBean(<span class="hljs-string">"helloWorld"</span>);    <br>      obj.getMessage();    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h2><p>ApplicationContext 是 Spring 应用程序中的中央接口，用于向应用程序提供配置信息</p><p>它继承了 BeanFactory 接口，所以 ApplicationContext 包含 BeanFactory 的所有功能以及更多功能！它的主要功能是支持大型的业务应用的创建</p><p>特性：</p><ul><li><p>Bean instantiation/wiring</p></li><li><p>Bean 的实例化/串联</p></li><li><p>自动的 BeanPostProcessor 注册</p></li><li><p>自动的 BeanFactoryPostProcessor 注册</p></li><li><p>方便的 MessageSource 访问（i18n）</p></li><li><p>ApplicationEvent 的发布</p></li></ul><p>与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化</p><p>这里是 ApplicationContext 的使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zoltanraffai;  <br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;  <br><span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean; <br><span class="hljs-keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldApp</span></span>&#123; <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>      ApplicationContext context=<span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>); <br>      HelloWorld obj = (HelloWorld) context.getBean(<span class="hljs-string">"helloWorld"</span>);    <br>      obj.getMessage();    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quartz流程及示例</title>
    <link href="/2020/03/01/2019-06-29-quartz/"/>
    <url>/2020/03/01/2019-06-29-quartz/</url>
    
    <content type="html"><![CDATA[<blockquote><p>定时任务是日常开发中非常常见的功能。</p></blockquote><a id="more"></a><p>对于简单的任务处理Spring的@Scheduled非常好用。  </p><p>如果处理更复杂的情况，比如需要宕机恢复或者集群调度，那么Quartz是个不错的轻量级方案。</p><p>一些重量级的第三方任务调度系统也是基于Quartz扩展的，比如XXL-JOB，本文直说quartz的实现原理，文末会附上实践代码。</p><h2 id="Quartz的模块"><a href="#Quartz的模块" class="headerlink" title="Quartz的模块"></a>Quartz的模块</h2><p><img src="https://uacoding.cn/images/posts/java/quartz/%E6%B5%81%E7%A8%8B1.png" srcset="/img/loading.gif" alt="quartz流程图1"></p><ul><li>Trigger定义了何时触发任务，可以说是一个触发器，主要是两种SimpleTrigger和CronTigger,其他Tigger基本都可以通过这两种实现。Trigger还可以定义错过的任务如何处理。下表是说明：</li></ul><p><img src="https://uacoding.cn/images/posts/java/quartz/%E6%B5%81%E7%A8%8B2.jpeg" srcset="/img/loading.gif" alt="quartz流程图2"></p><ul><li>Calendar与Trigger相反，Calendar定义哪些时间是特例，不能执行任务。Calendar的优先级高于Trigger。HolidayCalendar比较常用，定义了哪些节日是特殊情况。</li></ul><p><img src="https://uacoding.cn/images/posts/java/quartz/%E6%B5%81%E7%A8%8B3.png" srcset="/img/loading.gif" alt="quartz流程图3"></p><ul><li>Job 负责定义任务所处理的逻辑，实现类需要实现org.quartz.Job接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Job</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要留意的是QuartzJobBean抽象类已经默认替我们实现了Job接口，并对工厂进行了一些自动化配置，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzJobBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Job</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QuartzJobBean</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-comment">// execute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-keyword">this</span>);<br>            MutablePropertyValues pvs = <span class="hljs-keyword">new</span> MutablePropertyValues();<br>            pvs.addPropertyValues(context.getScheduler().getContext());<br>            pvs.addPropertyValues(context.getMergedJobDataMap());<br>            bw.setPropertyValues(pvs, <span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SchedulerException var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JobExecutionException(var4);<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.executeInternal(context);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeInternal</span><span class="hljs-params">(JobExecutionContext var1)</span> <span class="hljs-keyword">throws</span> JobExecutionException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们应用时可以通过继承QuartzJobBean来并重写executeInternal就可以实现任务配置和记录等操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleJob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QuartzJobBean</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void executeInternal(<span class="hljs-type">JobExecutionContext</span> context) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体示例代码在文末给出。</p><ul><li>通过抛出JobExecutionException可以强制控制任务后续处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobExecutionException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SchedulerException</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> refire = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//true: 重新执行任务（不会触发下一次）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> unscheduleTrigg = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//true: 直接标记Trigger完成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> unscheduleAllTriggs = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//true: 直接标记所有和Job相关的Trigger都已经完成</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Stateful Job。不同于一般的无状态任务，可以同时执行。有状态任务不能同时执行，而且需要保存状态。根据需要给可以Job类添加@PersistJobDataAfterExecution 或 @DisallowConcurrentExecution</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PersistJobDataAfterExecution</span><br><span class="hljs-meta">@DisallowConcurrentExecution</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatefulJob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Job</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>JobDetail 保存Job的元信息，包括类定义和设置。</p></li><li><p>SchedulerFactory负责初始化，读取配置文件，然后创建Scheduler</p></li><li><p>Scheduler是中枢调度器，负责管理Trigger／JobDetail和3个调度线程</p></li></ul><h2 id="springboot集成quartz"><a href="#springboot集成quartz" class="headerlink" title="springboot集成quartz"></a>springboot集成quartz</h2><p>本示例技术栈：</p><ul><li><p>springboot2.1.6</p></li><li><p>quartz2.3.0</p></li><li><p>tk.mybatis 实现自动化data操作</p></li></ul><p>上面可以说是说了一堆零件，那么如何使用呢？简单说一下需要留意的地方，springboot1.x和springboot2.x在配置上相比，2.x版本将quartz提供了starter依赖，所以可以通过application内直接配置相关参数即可，具体官网有可以去参考，本文讲的是java代码实现配置，当然依赖和自动配置依赖有所不同，请读者自行区分，不贴一大堆了，quartz核心依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--quartz 定时框架--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.quartz-scheduler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>quartz<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.properties配置参考：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=8081<br><br># 数据源配置<br>spring.datasource.driverClassName=com.mysql.jdbc.Driver<br>spring.datasource.url=jdbc:mysql://dev.51haohuo.net:3306/quartz?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT<br>spring.datasource.username=root<br>spring.datasource.password=hc<br><br># mybstis配置<br>mybatis.mapper-locations=classpath:mapper/*/*.xml<br>mybatis.type-aliases-package=com.zhangpk.bean<br>mybatis.configuration.callSettersOnNulls=true<br></code></pre></td></tr></table></figure><p>核心配置类，注释都在代码内了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleConfig</span> </span>&#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> SchedulerFactoryBean <span class="hljs-title">schedulerFactoryBean</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>SchedulerFactoryBean factory = <span class="hljs-keyword">new</span> SchedulerFactoryBean();<br>factory.setDataSource(dataSource);<br><br><span class="hljs-comment">// quartz参数</span><br>Properties prop = <span class="hljs-keyword">new</span> Properties();<br><span class="hljs-comment">// 任意值 集群节点中必须相同。</span><br>prop.put(<span class="hljs-string">"org.quartz.scheduler.instanceName"</span>, <span class="hljs-string">"MyScheduler"</span>);<br>prop.put(<span class="hljs-string">"org.quartz.scheduler.instanceId"</span>, <span class="hljs-string">"AUTO"</span>);<br><span class="hljs-comment">// 线程池配置</span><br>prop.put(<span class="hljs-string">"org.quartz.threadPool.class"</span>, <span class="hljs-string">"org.quartz.simpl.SimpleThreadPool"</span>);<br>prop.put(<span class="hljs-string">"org.quartz.threadPool.threadCount"</span>, <span class="hljs-string">"20"</span>);<br><span class="hljs-comment">// 优先级</span><br>prop.put(<span class="hljs-string">"org.quartz.threadPool.threadPriority"</span>, <span class="hljs-string">"5"</span>);<br><span class="hljs-comment">// JobStore配置</span><br>prop.put(<span class="hljs-string">"org.quartz.jobStore.class"</span>, <span class="hljs-string">"org.quartz.impl.jdbcjobstore.JobStoreTX"</span>);<br><span class="hljs-comment">// 集群配置</span><br>prop.put(<span class="hljs-string">"org.quartz.jobStore.isClustered"</span>, <span class="hljs-string">"true"</span>);<br><span class="hljs-comment">// 属性定义了Scheduler 实例检入到数据库中的频率(单位：毫秒)。</span><br><span class="hljs-comment">// Scheduler 检查是否其他的实例到了它们应当检入的时候未检入；这能指出一个失败的 Scheduler 实例，且当前 Scheduler 会以此来接管任何执行失败并可恢复的 Job。</span><br><span class="hljs-comment">//通过检入操作，Scheduler 也会更新自身的状态记录。clusterChedkinInterval 越小，Scheduler 节点检查失败的 Scheduler 实例就越频繁。默认值是 15000 (即15 秒)。</span><br>prop.put(<span class="hljs-string">"org.quartz.jobStore.clusterCheckinInterval"</span>, <span class="hljs-string">"15000"</span>);<br>prop.put(<span class="hljs-string">"org.quartz.jobStore.maxMisfiresToHandleAtATime"</span>, <span class="hljs-string">"1"</span>);<br><br>prop.put(<span class="hljs-string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="hljs-string">"12000"</span>);<br>prop.put(<span class="hljs-string">"org.quartz.jobStore.tablePrefix"</span>, <span class="hljs-string">"QRTZ_"</span>);<br>factory.setQuartzProperties(prop);<br><br>factory.setSchedulerName(<span class="hljs-string">"MyScheduler"</span>);<br><span class="hljs-comment">// 延时启动</span><br>factory.setStartupDelay(<span class="hljs-number">1</span>);<br>factory.setApplicationContextSchedulerContextKey(<span class="hljs-string">"applicationContextKey"</span>);<br><span class="hljs-comment">// 可选，QuartzScheduler</span><br><span class="hljs-comment">// 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了</span><br>factory.setOverwriteExistingJobs(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 设置自动启动，默认为true</span><br>factory.setAutoStartup(<span class="hljs-keyword">true</span>);<br><br><span class="hljs-keyword">return</span> factory;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成这些基础配置之后，我们需要继承上面提到的QuartzJobBean来实现动态任务调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleJob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QuartzJobBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br>    <span class="hljs-keyword">private</span> ExecutorService service = Executors.newSingleThreadExecutor();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeInternal</span><span class="hljs-params">(JobExecutionContext context)</span> </span>&#123;<br>        Job scheduleJob = (Job) context.getMergedJobDataMap().get(Job.JOB_PARAM_KEY);<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 执行任务</span><br>            logger.info(<span class="hljs-string">"任务准备执行，任务ID：&#123;&#125;"</span>, scheduleJob.getJobId());<br><br>            ScheduleRunnable task = <span class="hljs-keyword">new</span> ScheduleRunnable(scheduleJob.getBeanName(), scheduleJob.getMethodName(),<br>                    scheduleJob.getParams());<br>            Future&lt;?&gt; future = service.submit(task);<br>            future.get();<br>            <span class="hljs-keyword">long</span> times = System.currentTimeMillis() - startTime;<br><br>            logger.info(<span class="hljs-string">"任务执行完毕，任务ID：&#123;&#125; 总共耗时：&#123;&#125; 毫秒"</span>, scheduleJob.getJobId(), times);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">"任务执行失败，任务ID："</span> + scheduleJob.getJobId(), e);<br>            <span class="hljs-keyword">long</span> times = System.currentTimeMillis() - startTime;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里注意一点，我们是基于数据库来进行对定时任务的记录，重启恢复的操作的，具体在项目的resource目录下的sql脚本内有建表语句。</p><p>另外，由于没有任何页面，所以可以通过接口测试工具来进行调用实现，毕竟前端很弱，有时间的话会补上。</p><p><img src="https://uacoding.cn/images/posts/java/quartz/%E8%B0%83%E7%94%A8%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="quartz调用"></p><p>最后我们可以通过线程和quartz提供的删除、暂停、恢复等操作来实现任务调度，通过spring注入要执行的任务类，任务类中写我们要执行的任务就ok了。</p><p>github:<a href="https://github.com/producted/spring-learning/tree/master/scheduler" target="_blank" rel="noopener">https://github.com/producted/spring-learning/tree/master/scheduler</a></p>]]></content>
    
    
    <categories>
      
      <category>quartz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quartz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从源码看oauth2的token创建过程</title>
    <link href="/2020/03/01/2019-06-27-oauth2-crete-token/"/>
    <url>/2020/03/01/2019-06-27-oauth2-crete-token/</url>
    
    <content type="html"><![CDATA[<blockquote><p>oauth2的token生成工程源码解读。</p></blockquote><a id="more"></a><h2 id="工作流程图示例："><a href="#工作流程图示例：" class="headerlink" title="工作流程图示例："></a>工作流程图示例：</h2><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/oauth2%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="oauth2代码流程图"></p><p>看完源码图之后，再看内部构造，一个一个说。</p><h2 id="TokenEndpoint："><a href="#TokenEndpoint：" class="headerlink" title="TokenEndpoint："></a>TokenEndpoint：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//#1.处理/oauth/token请求</span><br><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/oauth/token"</span>, method=RequestMethod.POST)<br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title">postAccessToken</span><span class="hljs-params">(Principal principal, @RequestParam<br>Map&lt;String, String&gt; parameters)</span> <span class="hljs-keyword">throws</span> HttpRequestMethodNotSupportedException </span>&#123;<br><br><span class="hljs-keyword">if</span> (!(principal <span class="hljs-keyword">instanceof</span> Authentication)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientAuthenticationException(<br><span class="hljs-string">"There is no client authentication. Try adding an appropriate authentication filter."</span>);<br>&#125;<br><span class="hljs-comment">//获取clientId</span><br>String clientId = getClientId(principal);<br><span class="hljs-comment">//获取第三方应用的详细配置信息</span><br>ClientDetails authenticatedClient = getClientDetailsService().loadClientByClientId(clientId);<br><span class="hljs-comment">//使用第三方应用信息创建TokenRequest</span><br>TokenRequest tokenRequest = getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient);<br><span class="hljs-comment">//有没有传clientId</span><br><span class="hljs-keyword">if</span> (clientId != <span class="hljs-keyword">null</span> &amp;&amp; !clientId.equals(<span class="hljs-string">""</span>)) &#123;<br><span class="hljs-comment">// Only validate the client details if a client authenticated during this</span><br><span class="hljs-comment">// request.</span><br><span class="hljs-comment">//与配置里面的是否匹配</span><br><span class="hljs-keyword">if</span> (!clientId.equals(tokenRequest.getClientId())) &#123;<br><span class="hljs-comment">// double check to make sure that the client ID in the token request is the same as that in the</span><br><span class="hljs-comment">// authenticated client</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidClientException(<span class="hljs-string">"Given client ID does not match authenticated client"</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (authenticatedClient != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//检查scope</span><br>oAuth2RequestValidator.validateScope(tokenRequest, authenticatedClient);<br>&#125;<br><span class="hljs-comment">//grant_type是否存在值，对应四种授权模式和刷新token</span><br><span class="hljs-keyword">if</span> (!StringUtils.hasText(tokenRequest.getGrantType())) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidRequestException(<span class="hljs-string">"Missing grant type"</span>);<br>&#125;<br><span class="hljs-comment">//是否简化模式</span><br><span class="hljs-keyword">if</span> (tokenRequest.getGrantType().equals(<span class="hljs-string">"implicit"</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidGrantException(<span class="hljs-string">"Implicit grant type not supported from token endpoint"</span>);<br>&#125;<br><span class="hljs-comment">//是否是授权码模式</span><br><span class="hljs-keyword">if</span> (isAuthCodeRequest(parameters)) &#123;<br><span class="hljs-comment">// The scope was requested or determined during the authorization step</span><br><span class="hljs-keyword">if</span> (!tokenRequest.getScope().isEmpty()) &#123;<br>logger.debug(<span class="hljs-string">"Clearing scope of incoming token request"</span>);<br><span class="hljs-comment">//如果是授权码模式scope设置为空，根据获取code时的scope设置</span><br>tokenRequest.setScope(Collections.&lt;String&gt; emptySet());<br>&#125;<br>&#125;<br><span class="hljs-comment">//是否刷新令牌</span><br><span class="hljs-keyword">if</span> (isRefreshTokenRequest(parameters)) &#123;<br><span class="hljs-comment">// A refresh token has its own default scopes, so we should ignore any added by the factory here.</span><br><span class="hljs-comment">//设置scope</span><br>tokenRequest.setScope(OAuth2Utils.parseParameterList(parameters.get(OAuth2Utils.SCOPE)));<br>&#125;<br><span class="hljs-comment">//获取OAuth2AccessToken</span><br>OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);<br><span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedGrantTypeException(<span class="hljs-string">"Unsupported grant type: "</span> + tokenRequest.getGrantType());<br>&#125;<br><br><span class="hljs-keyword">return</span> getResponse(token);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>ClientDetails</p><p>上述代码可以看出在获取token时，接收的clientId通过这段代码：getClientDetailsService().loadClientByClientId(clientId); 会得到一个ClientDetails，我们继续看loadClientByClientId方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ClientDetails <span class="hljs-title">loadClientByClientId</span><span class="hljs-params">(String clientId)</span> <span class="hljs-keyword">throws</span> ClientRegistrationException </span>&#123;<br>        <span class="hljs-comment">// 通过clientDetailsStore根据clientId为key来进行获取</span><br>        ClientDetails details = (ClientDetails)<span class="hljs-keyword">this</span>.clientDetailsStore.get(clientId);<br>        <span class="hljs-keyword">if</span> (details == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchClientException(<span class="hljs-string">"No client with requested id: "</span> + clientId);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> details;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看一下clientDetailsStore是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, ClientDetails&gt; clientDetailsStore = <span class="hljs-keyword">new</span> HashMap();<br></code></pre></td></tr></table></figure><p>可以看到是一个map来进行存储其认识或者说协议好的客户端clientId和密码，那这个ClientDetails可以看做是一个bean，根据接收到的clientId获取的对应实体信息，大概可以这样理解，可能有误，但我暂时先这么看。</p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/client-details.png" srcset="/img/loading.gif" alt="oauth2代码流程图"></p><h2 id="TokenRequest"><a href="#TokenRequest" class="headerlink" title="TokenRequest"></a>TokenRequest</h2><p>那么TokenRequest又是什么呢？聪明的你应该已经猜到了，TokenRequest就可以看做是服务端生成token后的一个实例，就是上篇<a href="https://uacoding.cn/2019/06/26/oauth2/">oauth2入门及介绍</a>中的四种模式的请求实例，大概可以这么理解。上张图：</p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/token-request.png" srcset="/img/loading.gif" alt="oauth2代码流程图"></p><h2 id="创建token的核心工作类"><a href="#创建token的核心工作类" class="headerlink" title="创建token的核心工作类"></a>创建token的核心工作类</h2><p>我们看TokenEndPoint这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">OAuth2AccessToken token = <span class="hljs-keyword">this</span>.getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);<br></code></pre></td></tr></table></figure><p>我们看看这个grant方法，这个方法是this.getTokenGranter()，也就是TokenGranter接口的一个方法，该方法实现介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeTokenGranter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenGranter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;TokenGranter&gt; tokenGranters;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CompositeTokenGranter</span><span class="hljs-params">(List&lt;TokenGranter&gt; tokenGranters)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tokenGranters = <span class="hljs-keyword">new</span> ArrayList(tokenGranters);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span> </span>&#123;<br>        Iterator var3 = <span class="hljs-keyword">this</span>.tokenGranters.iterator();<br><br>        OAuth2AccessToken grant;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (!var3.hasNext()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            TokenGranter granter = (TokenGranter)var3.next();<br>            grant = granter.grant(grantType, tokenRequest);<br>        &#125; <span class="hljs-keyword">while</span>(grant == <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">return</span> grant;<br>    &#125;<br>    <span class="hljs-comment">// 其余方法略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有点类似于建造者模式，先把TokenGranter创建出来，然后调用grant方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractTokenGranter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenGranter</span> </span>&#123;<br>    <span class="hljs-comment">// 省略其他方法...</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthorizationServerTokenServices tokenServices;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.grantType.equals(grantType)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String clientId = tokenRequest.getClientId();<br>            ClientDetails client = <span class="hljs-keyword">this</span>.clientDetailsService.loadClientByClientId(clientId);<br>            <span class="hljs-keyword">this</span>.validateGrantType(grantType, client);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Getting access token for: "</span> + clientId);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAccessToken(client, tokenRequest);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tokenServices.createAccessToken(<span class="hljs-keyword">this</span>.getOAuth2Authentication(client, tokenRequest));<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最终是由AuthorizationServerTokenServices来实现token的创建，吧这个创建的方法贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        <span class="hljs-comment">// 先根据条件查看是否有当前的token</span><br>        OAuth2AccessToken existingAccessToken = <span class="hljs-keyword">this</span>.tokenStore.getAccessToken(authentication);<br>        OAuth2RefreshToken refreshToken = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (existingAccessToken != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 判断是否超时</span><br>            <span class="hljs-keyword">if</span> (!existingAccessToken.isExpired()) &#123;<br>                <span class="hljs-comment">// 没有超时继续使用</span><br>                <span class="hljs-keyword">this</span>.tokenStore.storeAccessToken(existingAccessToken, authentication);<br>                <span class="hljs-keyword">return</span> existingAccessToken;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (existingAccessToken.getRefreshToken() != <span class="hljs-keyword">null</span>) &#123;<br>                refreshToken = existingAccessToken.getRefreshToken();<br>                <span class="hljs-keyword">this</span>.tokenStore.removeRefreshToken(refreshToken);<br>            &#125;<br>            <span class="hljs-comment">// 如果超时则把token移除</span><br>            <span class="hljs-keyword">this</span>.tokenStore.removeAccessToken(existingAccessToken);<br>        &#125;<br>        <br>        <span class="hljs-comment">// refreshtoken刷新</span><br>        <span class="hljs-keyword">if</span> (refreshToken == <span class="hljs-keyword">null</span>) &#123;<br>            refreshToken = <span class="hljs-keyword">this</span>.createRefreshToken(authentication);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refreshToken <span class="hljs-keyword">instanceof</span> ExpiringOAuth2RefreshToken) &#123;<br>            ExpiringOAuth2RefreshToken expiring = (ExpiringOAuth2RefreshToken)refreshToken;<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; expiring.getExpiration().getTime()) &#123;<br>                refreshToken = <span class="hljs-keyword">this</span>.createRefreshToken(authentication);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 没有获取到token，说明需要创建</span><br>        OAuth2AccessToken accessToken = <span class="hljs-keyword">this</span>.createAccessToken(authentication, refreshToken);<br>        <span class="hljs-comment">// 创建完成放入tokenStore，这个tokenStore就是我们配置类内配置的存储位置</span><br>        <span class="hljs-keyword">this</span>.tokenStore.storeAccessToken(accessToken, authentication);<br>        refreshToken = accessToken.getRefreshToken();<br>        <span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.tokenStore.storeRefreshToken(refreshToken, authentication);<br>        &#125;<br>        <span class="hljs-keyword">return</span> accessToken;<br>    &#125;<br></code></pre></td></tr></table></figure><p>由此，token创建完成。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最近想做一套springboot的学习笔记，因为太菜，只能磊代码了，意在做一套开箱即用，开发具有参考价值的demo示例，方便以后参考：<a href="https://github.com/producted/spring-learning" target="_blank" rel="noopener">https://github.com/producted/spring-learning</a></p>]]></content>
    
    
    <categories>
      
      <category>oauth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oauth2入门及介绍</title>
    <link href="/2020/03/01/2019-06-26-oauth2/"/>
    <url>/2020/03/01/2019-06-26-oauth2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>告诉你oauth2整体思路以及几种模式。</p></blockquote><a id="more"></a><h2 id="OAuth的思路"><a href="#OAuth的思路" class="headerlink" title="OAuth的思路"></a>OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/oauth2%E6%B5%81%E7%A8%8B1.png" srcset="/img/loading.gif" alt="oauth运行流程"></p><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。<br>下面一一讲解客户端获取授权的四种模式。</p><h2 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p><h3 id="授权码模式（authorization-code）"><a href="#授权码模式（authorization-code）" class="headerlink" title="授权码模式（authorization code）"></a>授权码模式（authorization code）</h3><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F.png" srcset="/img/loading.gif" alt="oauth运行流程"></p><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p><p>下面是上面这些步骤所需要的参数。<br>A步骤中，客户端申请认证的URI，包含以下参数：<br>response_type：表示授权类型，必选项，此处的值固定为”code”<br>client_id：表示客户端的ID，必选项<br>redirect_uri：表示重定向URI，可选项<br>scope：表示申请的权限范围，可选项<br>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</p><p>代码示例-授权服务端配置：这里只显示核心配置客户端的一些东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    clients.inMemory()<br>            .withClient(<span class="hljs-string">"client1"</span>)<br>            .redirectUris(<span class="hljs-string">"http://www.baidu.com"</span>) <span class="hljs-comment">// 注册一个重定向地址</span><br>            .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"client1"</span>))<br>            .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>, <span class="hljs-string">"refresh_token"</span>)<br>            .scopes(<span class="hljs-string">"all"</span>)<br>            .and()<br>            .withClient(<span class="hljs-string">"client2"</span>)<br>            .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"client2"</span>))<br>            .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>, <span class="hljs-string">"refresh_token"</span>)<br>            .scopes(<span class="hljs-string">"all"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>请求方式：</p><p>通过这个链接<a href="http://localhost:8082/uaa/oauth/authorize?response_type=code&amp;client_id=client1&amp;redirect_uri=http://www.baidu.com&amp;scope=all获取code，拿到code之后：发起如下请求：" target="_blank" rel="noopener">http://localhost:8082/uaa/oauth/authorize?response_type=code&amp;client_id=client1&amp;redirect_uri=http://www.baidu.com&amp;scope=all获取code，拿到code之后：发起如下请求：</a></p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F1.png" srcset="/img/loading.gif" alt="oauth运行流程"></p><h3 id="简化模式（implicit）"><a href="#简化模式（implicit）" class="headerlink" title="简化模式（implicit）"></a>简化模式（implicit）</h3><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/%E7%AE%80%E5%8C%96%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F.png" srcset="/img/loading.gif" alt="oauth运行流程"></p><p>（A）客户端将用户导向认证服务器。</p><p>（B）用户决定是否给于客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p><p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p><p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p><p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p><p>（G）浏览器将令牌发给客户端。</p><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><p>response_type：表示授权类型，此处的值固定为”token”，必选项。<br>client_id：表示客户端的ID，必选项。<br>redirect_uri：表示重定向的URI，可选项。<br>scope：表示权限范围，可选项。<br>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</p><h3 id="密码模式（resource-owner-password-credentials）"><a href="#密码模式（resource-owner-password-credentials）" class="headerlink" title="密码模式（resource owner password credentials）"></a>密码模式（resource owner password credentials）</h3><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F.png" srcset="/img/loading.gif" alt="oauth运行流程"></p><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><p>grant_type：表示授权类型，此处的值固定为”password”，必选项。<br>username：表示用户名，必选项。<br>password：表示用户的密码，必选项。<br>scope：表示权限范围，可选项。</p><h3 id="客户端模式（client-credentials）"><a href="#客户端模式（client-credentials）" class="headerlink" title="客户端模式（client credentials）"></a>客户端模式（client credentials）</h3><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="https://uacoding.cn/images/posts/java/security-oauth2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F.png" srcset="/img/loading.gif" alt="oauth运行流程"></p><p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p><p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><p>granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。<br>scope：表示权限范围，可选项。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>阮一峰大佬：<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实oauth就是帮我们把两个应用之间隔离开来，通过oauth可以不透露密码的情况下实现两个系统的安全交互，这对用户来说是负责的，对我们开发人员来讲，具体代码已经做好了封装，我们只负责拿来用就可以了，也是福利。</p>]]></content>
    
    
    <categories>
      
      <category>oauth2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用spring security</title>
    <link href="/2020/03/01/2019-06-25-security/"/>
    <url>/2020/03/01/2019-06-25-security/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文只介绍怎么用，不会介绍security是什么。</p></blockquote><a id="more"></a><h2 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h2><p>对每个请求进行细粒度安全性控制的关键在于重载configure(HttpSecurity)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    http.authorizeRequests()                     <br>            .antMatchers(<span class="hljs-string">"/test"</span>).authenticated()<br>            <span class="hljs-comment">//.antMatchers("/test","/tests").authenticated()</span><br>            .antMatchers(HttpMethod.POST,<span class="hljs-string">"/tests"</span>).authenticated()<br>            .anyRequest().permitAll();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先调用<strong>authorizeRequests()</strong>，然后调用该方法所返回的对象的方法来配置请求级别的安全性细节。其中，第一次调用antMatchers()指定了对/test路径的请求需要认证。第二次调用antMatchers()更为具体，说明对/tests路径的HTTP POST请求必须要经过认证。最后anyRequest().permitAll()说明其他所有的请求都是允许的，不需要认证和任何的权限。 </p><p>antMatchers()方法中设定的路径支持Ant风格的通配符。</p><p>当然，antMatchers()同时也可以指定多个路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.antMatchers(<span class="hljs-string">"/test"</span>,<span class="hljs-string">"/tests"</span>).authenticated()<br></code></pre></td></tr></table></figure><p>authenticated()要求在执行该请求时，必须已经登录了应用，否则会出现如下错误。permitAll()方法允许请求没有任何的安全限制。 </p><p>用来定义如何保护路径的方法 ：</p><p>我们还可以修改之前的configure()方法，要求用户不仅需要认证，还要具备ROLE_USER权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http.authorizeRequests()<br>                <span class="hljs-comment">//.antMatchers("/test","/tests").authenticated()</span><br>                .antMatchers(<span class="hljs-string">"/haha/**"</span>).hasAuthority(<span class="hljs-string">"ROLE_USER"</span>)<br>                .antMatchers(<span class="hljs-string">"/haha/**"</span>).hasRole(<span class="hljs-string">"USER"</span>)<br>                <span class="hljs-comment">//.antMatchers(HttpMethod.POST,"/tests").authenticated()</span><br>                .anyRequest().permitAll();<br>    &#125;<br></code></pre></td></tr></table></figure><p>hasRole()是hasAuthority()的缩写，它会自动使用ROLE_前缀。</p><p>我们可以将任意的antMatchers()、anyRequest()连接起来，以满足Web应用安全规则的需要。</p><h2 id="使用Spring表达式进行保护"><a href="#使用Spring表达式进行保护" class="headerlink" title="使用Spring表达式进行保护"></a>使用Spring表达式进行保护</h2><p>表9.4.大多数方法都是一维的，也就是说不能叠加使用。但借助access()方法，我们也可以将SpEL作为声明访问限制的一种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">.antMatchers(<span class="hljs-string">"/haha/**"</span>).hasRole(<span class="hljs-string">"USER"</span>)<br>.antMatchers(<span class="hljs-string">"/haha/**"</span>).access(<span class="hljs-string">"hasRole('USER')"</span>)<br></code></pre></td></tr></table></figure><p>这两个效果是等价的。表9.5列出了Spring Security支持的所有SpEL表达式。 </p><h2 id="强制通道的安全性"><a href="#强制通道的安全性" class="headerlink" title="强制通道的安全性"></a>强制通道的安全性</h2><p>我们都知道HTTP发送的数据都是不加密的，所以对于一些敏感信息要通过HTTPS来加密发送。<br>传递到config()方法中HttpSecurity对象，除了具有authorizeRequests()方法以外，还有一个requiresChannel()方法，借助这个方法能够为各种URL模式声明所要求的通道。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>    protected void configure(HttpSecurity http) throws Exception &#123;<br>        <span class="hljs-selector-tag">http</span><br>                <span class="hljs-selector-class">.authorizeRequests</span>()<br>                <span class="hljs-selector-class">.antMatchers</span>(<span class="hljs-string">"/test"</span>,<span class="hljs-string">"/tests"</span>)<span class="hljs-selector-class">.authenticated</span>()<br>                <span class="hljs-selector-class">.anyRequest</span>()<span class="hljs-selector-class">.permitAll</span>()<br>                <span class="hljs-selector-class">.and</span>()<br>                <span class="hljs-selector-class">.requiresChannel</span>()<br>                <span class="hljs-selector-class">.antMatchers</span>(<span class="hljs-string">"/haha/ha"</span>)<span class="hljs-selector-class">.requiresSecure</span>()    <span class="hljs-comment">//需要HTTPS</span><br>                ;<br>    &#125;<br></code></pre></td></tr></table></figure><p>与之相反，有些页面不需要通过HTTPS传送，我们可以使用requiresInsecure()代替requiresSecure()方法。</p><p>防止跨站请求伪造(cross-site request forgery,CSRF)</p><p>如果一个站点欺骗用户提交请求到其他服务器的话，就会发生CSRF攻击。 </p><p>Spring Security3.2开启，默认会启用CSRF防护。因为我没怎么用到，所以细节就不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.csrf().disable()   <span class="hljs-comment">//禁用CSRF防护</span><br></code></pre></td></tr></table></figure><h2 id="认证用户"><a href="#认证用户" class="headerlink" title="认证用户"></a>认证用户</h2><p>如果你使用最简单的Spring Security配置的话，那么就能无偿得到一个登陆页。实际上，在重写configure(HttpSecurity)之前，我们都能使用一个简单却功能完备的登陆页，但是一旦重写了configure(HttpSecurity)方法，就失去了这个简单的登录页面。 </p><p>不过我们可以通过formLogin()方法把它找回来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http<br>               .formLogin()           <br>               .and()                           <br>               .csrf().disable()  <span class="hljs-comment">//禁用CSRF</span><br>                .authorizeRequests()         <br>                .antMatchers(<span class="hljs-string">"/test"</span>,<span class="hljs-string">"/tests"</span>).authenticated()<br>                .anyRequest().permitAll()<br>                ;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="添加自定义登录页面"><a href="#添加自定义登录页面" class="headerlink" title="添加自定义登录页面"></a>添加自定义登录页面</h2><p>上面可以看出，security给我们提供了默认的登录页面，当然，我们是可以自定义登录页面的，具体配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http<br>               .formLogin()<br>               .loginPage(<span class="hljs-string">"/login"</span>).defaultSuccessUrl(<span class="hljs-string">"/success"</span>).failureUrl(<span class="hljs-string">"/error"</span>)<br>               .and()<br>               .csrf().disable()<br>                .authorizeRequests()            <br>                .antMatchers(<span class="hljs-string">"/test"</span>,<span class="hljs-string">"/tests"</span>).authenticated()<br>                .anyRequest().permitAll()<br>                ;<br>    &#125;<br><br><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span><br>    </span>&#123;       <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注意：自定义的登陆页也需要username和password输入域！否则会一直认证失败！！！！同时，loginPage（）与自定义登陆页的action访问路径是一样的！！！</p><h2 id="Spring-Security使用Authentication获取当前用户信息"><a href="#Spring-Security使用Authentication获取当前用户信息" class="headerlink" title="Spring Security使用Authentication获取当前用户信息"></a>Spring Security使用Authentication获取当前用户信息</h2><p>Spring Security使用一个Authentication对象来描述当前用户的相关信息。SecurityContextHolder中持有的是当前用户的SecurityContext，而SecurityContext持有的是代表当前用户相关信息的Authentication的引用。这个Authentication对象不需要我们自己去创建，在与系统交互的过程中，Spring Security会自动为我们创建相应的Authentication对象，然后赋值给当前的SecurityContext。但是往往我们需要在程序中获取当前用户的相关信息，比如最常见的是获取当前登录用户的用户名。在程序的任何地方，通过如下方式我们可以获取到当前用户的用户名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCurrentUsername</span><span class="hljs-params">()</span> </span>&#123;<br><br>      Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br><br>      <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> UserDetails) &#123;<br><br>         <span class="hljs-keyword">return</span> ((UserDetails) principal).getUsername();<br><br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> Principal) &#123;<br><br>         <span class="hljs-keyword">return</span> ((Principal) principal).getName();<br><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> String.valueOf(principal);<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>通过Authentication.getPrincipal()可以获取到代表当前用户的信息，这个对象通常是UserDetails的实例。获取当前用户的用户名是一种比较常见的需求，关于上述代码其实Spring Security在Authentication中的实现类中已经为我们做了相关实现，所以获取当前用户的用户名最简单的方式应当如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCurrentUsername</span><span class="hljs-params">()</span> </span>&#123;<br><br>      <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication().getName();<br><br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="启用HTTP-Basic认证"><a href="#启用HTTP-Basic认证" class="headerlink" title="启用HTTP Basic认证"></a>启用HTTP Basic认证</h2><p>当在Web浏览器中使用时，它将向用户弹出一个简单的模拟对话框。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">http<br>.httpBasic()<br>.and()<br>...<br></code></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>退出功能是通过Servlet容器中的Filter实现的(默认情况下)，这个Filter会拦截针对”/logout”的请求。因此，为应用添加退出功能只需要添加以下的链接即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;a href="$&#123;pageContext.request.contextPath &#125;/logout"&gt;退出&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>在退出完成后，浏览器会重定向到“login?logout”，从而允许用户进行再次登录。如果你希望重定向到其他页面可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.logout().logoutSuccessUrl(<span class="hljs-string">"/error"</span>)<br></code></pre></td></tr></table></figure><p>logoutSuccessUrl(“/error”)表明在退出成功后，浏览器需要重定向到”/error”。我们还可以重写默认的LogoutFilter拦截路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.logout().logoutSuccessUrl(<span class="hljs-string">"/error"</span>).logoutUrl(<span class="hljs-string">"/tuichu"</span>)<br></code></pre></td></tr></table></figure><p>前面说到LogoutFilter默认会拦截针对”/logout”的请求，在这里我们通过logoutUrl(“/tuichu”)设置为拦截”/tuichu”的请求。同时将退出的请求路径更改为如下所示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;a href="$&#123;pageContext.request.contextPath &#125;/tuichu"&gt;退出&lt;/a&gt;<br></code></pre></td></tr></table></figure><h2 id="保护视图"><a href="#保护视图" class="headerlink" title="保护视图"></a>保护视图</h2><p>当为浏览器渲染html内容时，你可能希望视图中能够反映安全限制和相关的信息。或者你想根据用户被授予了什么权限，有条件的渲染特定的视图内容。渲染视图的两个重要方案就是：JSP和Thymeleaf。 </p><p>Spring Security本身提供了一个JSP标签库，而Thymeleaf通过特定的方言实现了与Spring Security的集成</p><p>Spring Security的JSP标签库</p><p>Spring Security的JSP标签库很小，就三个标签。 </p><p>为了使用JSP标签库，我们需要在JSP文件中声明它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">taglib</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"security"</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">"http://www.springframework.org/security/tags"</span> %&gt;</span><br></code></pre></td></tr></table></figure><h2 id="访问认证信息的页面控制"><a href="#访问认证信息的页面控制" class="headerlink" title="访问认证信息的页面控制"></a>访问认证信息的页面控制</h2><p>借助Spring Security的JSP标签库，所做的最简单的一件事就是便利的访问用户的认证信息。这恰恰是 &lt; security:authentication &gt;能为我们做的事情。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">hello<span class="hljs-tag">&lt;<span class="hljs-name">security:authentication</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"principal.username"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>property用来标示用户认证对象的一个属性。可用的属性取决于用户认证的方式。 </p><p>我们也可以将渲染属性的值赋给一个变量，那只需要在var属性中指明变量的名字即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">security:authentication</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"principal.username"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"name"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这个变量默认是定义在页面作用域内的，我们可以通过scope属性来更改变量作用域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">security:authentication</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"principal.username"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"name"</span>  <span class="hljs-attr">scope</span>=<span class="hljs-string">"request"</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="判断用户登录"><a href="#判断用户登录" class="headerlink" title="判断用户登录"></a>判断用户登录</h3><p>isAnonymous() 为 true则表示未登录，isAuthenticated()为true则表示已登录！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">!–匿名–</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">security:authorize</span> <span class="hljs-attr">access</span>=<span class="hljs-string">"isAnonymous()"</span>&gt;</span><br>    未登录，点击 <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">security:authorize</span>&gt;</span>　<br><span class="hljs-tag">&lt;<span class="hljs-name">!–登录–</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">security:authorize</span> <span class="hljs-attr">access</span>=<span class="hljs-string">"isAuthenticated()"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>登录成功！<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">security:authorize</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="条件性的渲染内容"><a href="#条件性的渲染内容" class="headerlink" title="条件性的渲染内容"></a>条件性的渲染内容</h3><p>有时候视图上的一部分内容需要根据用户被授予了什么权限来确定是否渲染。Spring Security的&lt; security:authorize &gt;JSP标签能够根据用户被授予的权限有条件的渲染页面的部分内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">hello<span class="hljs-tag">&lt;<span class="hljs-name">security:authentication</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"principal.username"</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">security:authorize</span> <span class="hljs-attr">access</span>=<span class="hljs-string">"hasRole('user')"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>有条件性的渲染的内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">security:authorize</span>&gt;</span><br></code></pre></td></tr></table></figure><p>access属性被赋值给一个SpEL表达式，这个表达式的值确定&lt; security:authorize &gt;标签内主体内的内容是否渲染。</p><p>剩余问题，thymeleaf的整合使用。</p><hr><p>近期整合了thymeleaf，使用oauth2结合security实现了带点登录，github地址：</p><p><a href="https://github.com/producted/spring-learning/tree/master/zpk-oauth2-sso-demo" target="_blank" rel="noopener">https://github.com/producted/spring-learning/tree/master/zpk-oauth2-sso-demo</a></p>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于spring cloud注册中心nacos</title>
    <link href="/2020/03/01/2019-06-20-%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/03/01/2019-06-20-%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么会接触nacos？"><a href="#为什么会接触nacos？" class="headerlink" title="为什么会接触nacos？"></a>为什么会接触nacos？</h2><p>学习nacos的主要原因是因为eureka2.x的闭源策略，无论其基于什么原因吧，总之长久来看eureka貌似不是最好的选择了，这种情况下悄悄的看一下别的注册中心-nacos。</p><a id="more"></a><h2 id="关于springcloud组件的抽象理解"><a href="#关于springcloud组件的抽象理解" class="headerlink" title="关于springcloud组件的抽象理解"></a>关于springcloud组件的抽象理解</h2><p>其实注册中心使用nacos并不会影响到我们应用层多少的，仔细看看，其实还是我该怎样调用怎样调用，跟用不用Nacos没啥关系，确实是这样，对于Spring Cloud老手来说，就算我们更换了Nacos作为新的服务注册中心，其实对于我们应用层面的代码是没有影响的。那么为什么Spring Cloud可以带给我们这样的完美编码体验呢？实际上，这完全归功于Spring Cloud Common的封装，由于在服务注册与发现、客户端负载均衡等方面都做了很好的抽象，而上层应用方面依赖的都是这些抽象接口，而非针对某个具体中间件的实现。所以，在Spring Cloud中，我们可以很方便的去切换服务治理方面的中间件。</p><h2 id="nacos与eureka有什么区别？"><a href="#nacos与eureka有什么区别？" class="headerlink" title="nacos与eureka有什么区别？"></a>nacos与eureka有什么区别？</h2><p>说说我最近研究的一些心得，总结几点区别，如下：</p><ul><li><p>nacos与springboot版本冲突性太强，比如官方文档说明的0.2.x版本对应的是springboot2.x版本，实则不然，当我用springboot2.1x时是无法实现服务发现与注册的，而eureka不存在这方面问题，就这个问题，整整折腾了我大半天，最后发现springboot2.0.x版本就可以完成注册，亏死了。</p></li><li><p>nacos的配置管理做得比较好点，可视化界面发起配置的编辑，和springconfig一样，使用springcloud原生注解@RefreshScope可以实现动态刷新，这点体现还是不错的，对比springcloud config而言的话，是要方便一些。</p></li><li><p>nacos集群基于mysql数据库来实现动态管理调用，与其他的中间件相比，在实现上并没有采用分布式算法来解决一致性问题，而是采用了比较常规的集中化存储来实现。由于采用单一数据源的方式，直接解决了分布式一致性问题，所以从学习成本的角度上来说，Nacos的实现原理会更容易被理解和接受。但是，从部署的负责度和硬件投入成本上来说，与etcd、consul、zookeeper这些通过算法方式解决一致性问题的中间件相比，就显得不足了；同时，在引入MySQL的存储时，由于多了一个中间件的存在，整个Nacos系统的整体可用性一定是会所有下降的。反观一下eureka，eureka集群下，eureka server是把互相之间的eureka模块来进行相互注册，不存在leader这一说，就是说你失败，ok我不认识你了，你突然又好了，那么欢迎你回来，这点和zookeeper有点像，但是zookeeper集群下是有它自己的算法来实现leader的。</p></li><li><p>已经不想继续进行下去nacos了，因为其集群环境下基于数据库版本匹配太短缺，我这边满足不了，文档上说5.6+版本均可，而我mysql版本是5.7.2仍然给我抛了一天异常，懒得搞了，坐等nacos成熟之后，或许会再抽出时间研究一下，毕竟它的服务降级也还是可以研究一下的…</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda表达式浅析</title>
    <link href="/2020/03/01/2019-05-05-lambda-info/"/>
    <url>/2020/03/01/2019-05-05-lambda-info/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇将告诉你lambda是什么，并且简单举例示意。</p></blockquote><a id="more"></a><h3 id="lambda是什么？"><a href="#lambda是什么？" class="headerlink" title="lambda是什么？"></a>lambda是什么？</h3><ul><li><p>lambda 函数是一个可以接收任意多个参数（包括可选参数）并且返回单个表达式值的匿名函数。 （注意：lambda 函数不能包含命令，它们所包含的表达式也不能超过一个）</p></li><li><p>lambda函数比较轻便，即用即扔，很适合需要完成某一项简单功能，但是这个简单的功能只在此一处使用，连名字都很随意的情况下；</p></li><li><p>lambda是匿名函数，一般用来给filter，map，reduce这样的函数式编程服务；</p></li><li><p>作为回调函数，可以传递给某些应用，比如消息处理等。</p></li></ul><p>举一个lambda应用非常简单的栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String firstName;<br>    <span class="hljs-keyword">private</span> String gen;<br>&#125;<br> <br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Person&gt; <span class="hljs-title">getPersons</span><span class="hljs-params">(<span class="hljs-keyword">int</span> personNum)</span> </span>&#123;<br>        String[] firstName = &#123;<span class="hljs-string">"孙"</span>,<span class="hljs-string">"上官"</span>,<span class="hljs-string">"刘"</span>,<span class="hljs-string">"李"</span>,<span class="hljs-string">"赵"</span>,<span class="hljs-string">"李"</span>,<span class="hljs-string">"王"</span>,<span class="hljs-string">"张"</span>&#125;;<br>        String[] endName = &#123;<span class="hljs-string">"宏强"</span>,<span class="hljs-string">"三"</span>,<span class="hljs-string">"四"</span>,<span class="hljs-string">"壁咚"</span>,<span class="hljs-string">"古来"</span>,<span class="hljs-string">"八戒"</span>,<span class="hljs-string">"恒达"</span>&#125;;<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; personNum - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> findex = <span class="hljs-keyword">new</span> Random().nextInt(firstName.length);<br>            <span class="hljs-keyword">int</span> eindex = <span class="hljs-keyword">new</span> Random().nextInt(endName.length);<br>            <span class="hljs-keyword">int</span> age = (findex + <span class="hljs-number">1</span>) * (eindex +<span class="hljs-number">1</span>);<br>            Person person = <span class="hljs-keyword">new</span> Person();<br>            person.setAge(age);<br>            person.setName(endName[eindex] + firstName[findex]);<br>            person.setFirstName(firstName[findex]);<br>            person.setGen(age % <span class="hljs-number">3</span> ==<span class="hljs-number">0</span>?<span class="hljs-string">"男"</span>:<span class="hljs-string">"女"</span>);<br>            personList.add(person);<br>        &#125;<br>        <span class="hljs-keyword">return</span> personList;<br>    &#125;<br></code></pre></td></tr></table></figure><p>用上面person作为集合元素，求出集合中男的人数有多少，简单吧，来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> List&lt;Person&gt; persons = getPersons(<span class="hljs-number">14</span>);<br> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>Iterator&lt;Person&gt; iterator = persons.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>Person next = iterator.next();<br><span class="hljs-keyword">if</span> (next.getGen().equals(<span class="hljs-string">"男"</span>))<br>count++;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用for循环直接遍历等等，既然说lambda，我们看一下lambda结合stream的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> count1 = persons.stream().filter(x -&gt; x.getGen().equals(<span class="hljs-string">"男"</span>)).count();<br></code></pre></td></tr></table></figure><p>so beautiful！不太理解是吧，来更深入一点看看一个自定义的函数式编程规范：</p><h3 id="自定义一个实例"><a href="#自定义一个实例" class="headerlink" title="自定义一个实例"></a>自定义一个实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-comment">//函数式接口检查注解 只能存在一个抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WorkerInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br> <br>     <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">doSomeWork</span><span class="hljs-params">(T t)</span></span>;<br>     <span class="hljs-comment">//取反</span><br>     <span class="hljs-function"><span class="hljs-keyword">default</span> WorkerInterface&lt;T&gt; <span class="hljs-title">workTest</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-keyword">return</span> t -&gt; !doSomeWork(t);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先要明白函数式接口只允许接口内有一个抽象方法，那么，static和default修饰的还是可以存在的。至于@FunctionalInterface注解，它的作用如下：</p><p>1、该注解只能标记在”有且仅有一个抽象方法”的接口上。</p><p>2、JDK8接口中的静态方法和默认方法，都不算是抽象方法。</p><p>3、接口默认继承java.lang.Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法。</p><p>4、该注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错。</p><p>还没完，上最后代码，还是关于lambda的简单应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerInterfaceTest</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WorkerInterface&lt;Integer&gt; a = x -&gt; x &lt; <span class="hljs-number">6</span>;<br>        System.out.println(a.doSomeWork(<span class="hljs-number">5</span>));<br>        System.out.println(a.workTest().doSomeWork(<span class="hljs-number">5</span>));<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda常用语法</title>
    <link href="/2020/03/01/2019-04-30-lambda/"/>
    <url>/2020/03/01/2019-04-30-lambda/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用javaProgrammers和phpProgrammers两个泛型为Person的List集合来做示例</p></blockquote><a id="more"></a><p>关于lambda表达式的认识，可看<a href="https://uacoding.cn/2019/05/05/lambda-info/" title="My Blog">java中的lambda表达式浅析</a>，本篇讲的是stream的日常使用，当然也会结合lambda来编写一些，由于是小白，所以本篇只能不断更新，用到哪更到哪吧，当笔记用用还蛮不错。</p><p><strong>目录</strong></p><ul><li>[TOC]</li></ul><h2 id="使用Lambdas和Streams"><a href="#使用Lambdas和Streams" class="headerlink" title="使用Lambdas和Streams"></a>使用Lambdas和Streams</h2><p>Stream是对集合的包装,通常和lambda一起使用。 使用lambdas可以支持许多操作,如 map, filter, limit, sorted, count, min, max, sum, collect 等等。 同样,Stream使用懒运算,他们并不会真正地读取所有数据,遇到像getFirst() 这样的方法就会结束链式语法。:heart_eyes:</p><h3 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"所有程序员的姓名:"</span>);  <br>javaProgrammers.forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  <br>phpProgrammers.forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));<br></code></pre></td></tr></table></figure><p>同样使用forEach方法,增加程序员的工资5%:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"给程序员加薪 5% :"</span>);  <br>Consumer&lt;Person&gt; giveRaise = e -&gt; e.setSalary(e.getSalary() / <span class="hljs-number">100</span> * <span class="hljs-number">5</span> + e.getSalary());  <br>  <br>javaProgrammers.forEach(giveRaise);  <br>phpProgrammers.forEach(giveRaise);<br></code></pre></td></tr></table></figure><h3 id="filter方法过滤需要的条件"><a href="#filter方法过滤需要的条件" class="headerlink" title="filter方法过滤需要的条件"></a>filter方法过滤需要的条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"下面是月薪超过 $1,400 的PHP程序员:"</span>)  <br>phpProgrammers.stream()  <br>          .filter((p) -&gt; (p.getSalary() &gt; <span class="hljs-number">1400</span>))  <br>          .forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));<br></code></pre></td></tr></table></figure><p>也可以定义过滤器,然后重用它们来执行其他操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义 filters  </span><br>Predicate&lt;Person&gt; ageFilter = (p) -&gt; (p.getAge() &gt; <span class="hljs-number">25</span>);  <br>Predicate&lt;Person&gt; salaryFilter = (p) -&gt; (p.getSalary() &gt; <span class="hljs-number">1400</span>);  <br>Predicate&lt;Person&gt; genderFilter = (p) -&gt; (<span class="hljs-string">"female"</span>.equals(p.getGender()));  <br>  <br>System.out.println(<span class="hljs-string">"下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:"</span>);  <br>phpProgrammers.stream()  <br>          .filter(ageFilter)  <br>          .filter(salaryFilter)  <br>          .filter(genderFilter)  <br>          .forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  <br>  <br><span class="hljs-comment">// 重用filters  </span><br>System.out.println(<span class="hljs-string">"年龄大于 24岁的女性 Java programmers:"</span>);  <br>javaProgrammers.stream()  <br>          .filter(ageFilter)  <br>          .filter(genderFilter)  <br>          .forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));<br></code></pre></td></tr></table></figure><h3 id="limit方法"><a href="#limit方法" class="headerlink" title="limit方法"></a>limit方法</h3><p>可以限制结果集的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"最前面的3个 Java programmers:"</span>);  <br>javaProgrammers.stream()  <br>          .limit(<span class="hljs-number">3</span>)  <br>          .forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  <br>  <br>  <br>System.out.println(<span class="hljs-string">"最前面的3个女性 Java programmers:"</span>);  <br>javaProgrammers.stream()  <br>          .filter(genderFilter)  <br>          .limit(<span class="hljs-number">3</span>)  <br>          .forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));<br></code></pre></td></tr></table></figure><h3 id="skip方法"><a href="#skip方法" class="headerlink" title="skip方法"></a>skip方法</h3><p>通常可以结合limit方法来说明跳过第几个来进行查询，需要注意的是skip方法需要放在limit方法前面执行</p><h3 id="sorted方法排序"><a href="#sorted方法排序" class="headerlink" title="sorted方法排序"></a>sorted方法排序</h3><p>在下面的例子中,将根据名字和薪水排序Java程序员,放到一个list中,然后显示列表:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"根据 name 排序,并显示前5个 Java programmers:"</span>);  <br>List&lt;Person&gt; sortedJavaProgrammers = javaProgrammers  <br>          .stream()  <br>          .sorted((p, p2) -&gt; (p.getFirstName().compareTo(p2.getFirstName())))  <br>          .limit(<span class="hljs-number">5</span>)  <br>          .collect(toList());  <br>  <br>sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; %n"</span>, p.getFirstName(), p.getLastName()));  <br>   <br>System.out.println(<span class="hljs-string">"根据 salary 排序 Java programmers:"</span>);  <br>sortedJavaProgrammers = javaProgrammers  <br>          .stream()  <br>          .sorted( (p, p2) -&gt; (p.getSalary() - p2.getSalary()) )  <br>          .collect( toList() );  <br>  <br>sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(<span class="hljs-string">"%s %s; %n"</span>, p.getFirstName(), p.getLastName()));<br></code></pre></td></tr></table></figure><h3 id="min和max方法"><a href="#min和max方法" class="headerlink" title="min和max方法"></a>min和max方法</h3><p>比如如果只对最低和最高的薪水感兴趣,比排序后选择第一个/最后一个 更快的是min和max方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"工资最低的 Java programmer:"</span>);  <br>Person pers = javaProgrammers  <br>          .stream()  <br>          .min((p1, p2) -&gt; (p1.getSalary() - p2.getSalary()))  <br>          .get()  <br>  <br>System.out.printf(<span class="hljs-string">"Name: %s %s; Salary: $%,d."</span>, pers.getFirstName(), pers.getLastName(), pers.getSalary())  <br>  <br>System.out.println(<span class="hljs-string">"工资最高的 Java programmer:"</span>);  <br>Person person = javaProgrammers  <br>          .stream()  <br>          .max((p, p2) -&gt; (p.getSalary() - p2.getSalary()))  <br>          .get()  <br>  <br>System.out.printf(<span class="hljs-string">"Name: %s %s; Salary: $%,d."</span>, person.getFirstName(), person.getLastName(), person.getSalary())<br></code></pre></td></tr></table></figure><h3 id="collect方法合map方法结合"><a href="#collect方法合map方法结合" class="headerlink" title="collect方法合map方法结合"></a>collect方法合map方法结合</h3><p>上面的例子中我们已经看到 collect 方法是如何工作的。 结合 map 方法,我们可以使用 collect 方法来将我们的结果集放到一个字符串,一个 Set 或一个TreeSet中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"将 PHP programmers 的 first name 拼接成字符串:"</span>);  <br>String phpDevelopers = phpProgrammers  <br>          .stream()  <br>          .map(Person::getFirstName)  <br>          .collect(joining(<span class="hljs-string">" ; "</span>)); <span class="hljs-comment">// 在进一步的操作中可以作为标记(token)     </span><br>  <br>System.out.println(<span class="hljs-string">"将 Java programmers 的 first name 存放到 Set:"</span>);  <br>Set&lt;String&gt; javaDevFirstName = javaProgrammers  <br>          .stream()  <br>          .map(Person::getFirstName)  <br>          .collect(toSet());  <br>  <br>System.out.println(<span class="hljs-string">"将 Java programmers 的 first name 存放到 TreeSet:"</span>);  <br>TreeSet&lt;String&gt; javaDevLastName = javaProgrammers  <br>          .stream()  <br>          .map(Person::getLastName)  <br>          .collect(toCollection(TreeSet::<span class="hljs-keyword">new</span>));<br></code></pre></td></tr></table></figure><h3 id="Streams可以是并行的-parallel"><a href="#Streams可以是并行的-parallel" class="headerlink" title="Streams可以是并行的(parallel)"></a>Streams可以是并行的(parallel)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"计算付给 Java programmers 的所有money:"</span>);  <br><span class="hljs-keyword">int</span> totalSalary = javaProgrammers  <br>          .parallelStream()  <br>          .mapToInt(p -&gt; p.getSalary())  <br>          .sum();<br></code></pre></td></tr></table></figure><h3 id="summaryStatistics方法来进行聚合"><a href="#summaryStatistics方法来进行聚合" class="headerlink" title="summaryStatistics方法来进行聚合"></a>summaryStatistics方法来进行聚合</h3><p>可以使用summaryStatistics方法获得stream 中元素的各种汇总数据。 接下来,我们可以访问这些方法,比如getMax, getMin, getSum或getAverage:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);  <br>IntSummaryStatistics stats = numbers  <br>          .stream()  <br>          .mapToInt((x) -&gt; x)  <br>          .summaryStatistics();  <br>  <br>System.out.println(<span class="hljs-string">"List中最大的数字 : "</span> + stats.getMax());  <br>System.out.println(<span class="hljs-string">"List中最小的数字 : "</span> + stats.getMin());  <br>System.out.println(<span class="hljs-string">"所有数字的总和   : "</span> + stats.getSum());  <br>System.out.println(<span class="hljs-string">"所有数字的平均值 : "</span> + stats.getAverage());<br></code></pre></td></tr></table></figure><h3 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h3><h4 id="去除List中重复的String"><a href="#去除List中重复的String" class="headerlink" title="去除List中重复的String"></a>去除List中重复的String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List unique = list.stream().distinct().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="去除List中重复的对象"><a href="#去除List中重复的对象" class="headerlink" title="去除List中重复的对象"></a>去除List中重复的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据name去重</span><br>List&lt;Person&gt; unique = persons.stream().collect(<br>            Collectors.collectingAndThen(<br>                    Collectors.toCollection(() -&gt; <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(Person::getName))), ArrayList::<span class="hljs-keyword">new</span>)<br>);<br><br><span class="hljs-comment">// 根据name,sex两个属性去重</span><br>List&lt;Person&gt; unique = persons.stream().collect(<br>           Collectors. collectingAndThen(<br>                    Collectors.toCollection(() -&gt; <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getName() + <span class="hljs-string">";"</span> + o.getSex()))), ArrayList::<span class="hljs-keyword">new</span>)<br>);<br></code></pre></td></tr></table></figure><h4 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h4><p>从一个Person对象的List集合，取出id和name组成一个map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; collect = list.stream().collect(Collectors.toMap(p -&gt; p.getId(), p -&gt; p.getName()));<br></code></pre></td></tr></table></figure><h3 id="分组后聚合"><a href="#分组后聚合" class="headerlink" title="分组后聚合"></a>分组后聚合</h3><p>谈谈今天工作中遇到的，先说说需求哈，按账户类型分组后，再按收支类型分组，并统计金额和笔数，不明白，怕想不起来是啥是吗，放张图：</p><p><img src="https://uacoding.cn/images/posts/java/lombok.png" srcset="/img/loading.gif" alt="" title="lambda_flag"></p><p>看看代码实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;BeanMap&lt;String, Object&gt;&gt; list = accountChgService.queryUserBills(obj);<br><span class="hljs-comment">// 获取账户分类信息 -&gt; 示例：余额账户:总支出xx笔，xx元；总收入xx笔，xx元...</span><br>List&lt;BeanMap&gt; cofferInfos = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">// 按账户类型分组</span><br>Map&lt;Integer, List&lt;BeanMap&lt;String, Object&gt;&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(beanmap -&gt; beanmap.getIntegerValue(<span class="hljs-string">"acctType"</span>)));<br>collect.keySet().forEach(acctType -&gt; &#123;<br><span class="hljs-comment">// 按收入类型分组</span><br>Map&lt;Integer, List&lt;BeanMap&lt;String, Object&gt;&gt;&gt; agTypeCol = collect.get(acctType).stream().collect(Collectors.groupingBy(beanmap -&gt; beanmap.getIntegerValue(<span class="hljs-string">"agType"</span>)));<br>agTypeCol.keySet().forEach(agtype -&gt; &#123;<br>Long count = agTypeCol.get(agtype).stream().count();<br>Integer inFee = agTypeCol.get(agtype)<br>.stream()<br>.mapToInt(beanmap -&gt; beanmap.getIntegerValue(<span class="hljs-string">"inFee"</span>))<br>.sum();<br>Integer outFee = agTypeCol.get(agtype)<br>.stream()<br>.mapToInt(beanmap -&gt; beanmap.getIntegerValue(<span class="hljs-string">"outFee"</span>))<br>.sum();<br>BeanMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> BeanMap&lt;&gt;();<br>map.put(<span class="hljs-string">"acctType"</span>,acctType);<br>map.put(<span class="hljs-string">"agType"</span>,agtype);<br>map.put(<span class="hljs-string">"count"</span>, count);<br>map.put(<span class="hljs-string">"sumInfee"</span>,inFee);<br>map.put(<span class="hljs-string">"sumOutFee"</span>,outFee);<br>cofferInfos.add(map);<br>&#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>PS：BeanMap是我自定义的一个继承了HashMap的类，list查询出来的数据是列表要展示的，包括了收入金额（inFee），支出金额（outFee），说白了，就是不想写这么简单又啰嗦的SQL语句了，所以代码来解决一下，这种写法不见得是最优秀的，后续如果理解或者发现了更好的方式，放上来…</p><h2 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h2><p>在stream内如何使外部变量进行运算，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; itgs = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>, <span class="hljs-number">9</span>);<br>        itgs.forEach(v -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (v == <span class="hljs-number">3</span>) &#123;<br>                index++;<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面会报错，要求index必须是final修饰，这种情况暂时找不到太好的解决办法，网上说可以定义为全局变量来解决，但这我不认为是好的，毕竟不能因为用了stream而改变代码结构。</p><p>先总结这些，待续…</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不可不说的 Java “锁”事</title>
    <link href="/2020/03/01/2019-04-27-face-lock/"/>
    <url>/2020/03/01/2019-04-27-face-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p></blockquote><a id="more"></a><p><strong>目录</strong></p><p>[TOC]</p><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p><p><img src="https://uacoding.cn/images/posts/face/java%E9%94%81%E7%9B%AE%E5%BD%95.jpg" srcset="/img/loading.gif" alt="java 锁目录"></p><h3 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="https://uacoding.cn/images/posts/face/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="乐观锁和悲观锁对比"></p><p>根据从上面的概念描述我们可以发现：</p><ul><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p></li><li><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p></li></ul><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p><p><img src="https://uacoding.cn/images/posts/face/%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.jpg" srcset="/img/loading.gif" alt="两种锁的调用方式"></p><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li><p>需要读写的内存值 V。</p></li><li><p>进行比较的值 A。</p></li><li><p>要写入的新值 B。</p></li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><p><img src="https://uacoding.cn/images/posts/face/atomicInteger.jpg" srcset="/img/loading.gif" alt="atomicInteger"></p><p>根据定义我们可以看出各属性的作用：</p><ul><li><p>unsafe：获取并操作内存的数据。</p></li><li><p>valueOffset：存储value在AtomicInteger中的偏移量。</p></li><li><p>value：存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</p></li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><p><img src="https://uacoding.cn/images/posts/face/unsafe.jpg" srcset="/img/loading.gif" alt="unsafe"></p><p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><p>1.[ABA问题。]CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p><p>2.[循环时间长开销大。]CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p><p>3.[只能保证一个共享变量的原子操作。]对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h3><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="https://uacoding.cn/images/posts/face/%E8%87%AA%E6%97%8B%E9%94%81%E5%9B%BE%E8%A7%A3.jpg" srcset="/img/loading.gif" alt="自旋锁图解"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="https://uacoding.cn/images/posts/face/%E8%87%AA%E6%97%8B%E9%94%81code.jpg" srcset="/img/loading.gif" alt="自旋锁code"></p><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。<br>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p><h3 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><h4 id="Mark-Word："><a href="#Mark-Word：" class="headerlink" title="Mark Word："></a>Mark Word：</h4><p>默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><h4 id="Klass-Point："><a href="#Klass-Point：" class="headerlink" title="Klass Point："></a>Klass Point：</h4><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><p><img src="https://uacoding.cn/images/posts/face/%E5%9B%9B%E7%A7%8D%E9%94%81%E7%9A%84%E7%89%B9%E7%82%B9%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="四种锁的特点图.jpg"></p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img src="https://uacoding.cn/images/posts/face/%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E7%8A%B6%E6%80%81.jpg" srcset="/img/loading.gif" alt="锁的升级状态"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><p><img src="https://uacoding.cn/images/posts/face/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.jpg" srcset="/img/loading.gif" alt="公平锁和非公平锁"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。<br>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="https://uacoding.cn/images/posts/face/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%812.jpg" srcset="/img/loading.gif" alt="公平锁和非公平锁2"></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="https://uacoding.cn/images/posts/face/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81code.jpg" srcset="/img/loading.gif" alt="公平锁和非公平锁code"></p><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。<br>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="https://uacoding.cn/images/posts/face/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81code2.jpg" srcset="/img/loading.gif" alt="公平锁和非公平锁code2"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="https://uacoding.cn/images/posts/face/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81code3.jpg" srcset="/img/loading.gif" alt="公平锁和非公平锁code3"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。<br>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h3 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><p><img src="https://uacoding.cn/images/posts/face/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.jpg" srcset="/img/loading.gif" alt="可重入锁和非可重入锁"></p><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="https://uacoding.cn/images/posts/face/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%812.jpg" srcset="/img/loading.gif" alt="可重入锁和非可重入锁2"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="https://uacoding.cn/images/posts/face/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%813.jpg" srcset="/img/loading.gif" alt="可重入锁和非可重入锁3"></p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。<br>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p><img src="https://uacoding.cn/images/posts/face/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%814.jpg" srcset="/img/loading.gif" alt="可重入锁和非可重入锁4"></p><h3 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h3><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="https://uacoding.cn/images/posts/face/%E7%8B%AC%E4%BA%AB%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81.jpg" srcset="/img/loading.gif" alt="独享锁和共享锁"></p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。<br>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。</p><p>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><p><img src="https://uacoding.cn/images/posts/face/%E7%8B%AC%E4%BA%AB%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%812.jpg" srcset="/img/loading.gif" alt="独享锁和共享锁2"></p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><p><img src="https://uacoding.cn/images/posts/face/%E7%8B%AC%E4%BA%AB%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%813.jpg" srcset="/img/loading.gif" alt="独享锁和共享锁3"></p><ul><li><p>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</p></li><li><p>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</p></li><li><p>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</p></li><li><p>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</p></li><li><p>如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</p></li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><p><img src="https://uacoding.cn/images/posts/face/%E7%8B%AC%E4%BA%AB%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%814.jpg" srcset="/img/loading.gif" alt="独享锁和共享锁4"></p><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="https://uacoding.cn/images/posts/face/%E7%8B%AC%E4%BA%AB%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%815.jpg" srcset="/img/loading.gif" alt="独享锁和共享锁5"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>美团技术团队</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说自定义注解及简单使用</title>
    <link href="/2020/03/01/2019-04-24-java-annotation/"/>
    <url>/2020/03/01/2019-04-24-java-annotation/</url>
    
    <content type="html"><![CDATA[<p>哪里不懂磕哪里:smile:</p><blockquote><p>谈及注解，应该都很熟悉不过了，例如你在web控制层需要@RequestMapping来映射路径，有碧如你的借口实现类上面的@Override… 那么，这些注解怎么来的，我们如何自定义注解来完成一些功能？</p></blockquote><a id="more"></a><h3 id="注解是什么"><a href="#注解是什么" class="headerlink" title="注解是什么"></a>注解是什么</h3><p>Annotation（注解）就是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。Annotion(注解)是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。</p><p>Annotation(注解)是JDK5.0及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中。</p><h3 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h3><ul><li><p>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等</p></li><li><p>跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2依赖注入，未来java开发，将大量注解配置，具有很大用处;</p></li><li><p>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</p></li></ul><h3 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h2 id="注解的组成"><a href="#注解的组成" class="headerlink" title="注解的组成"></a>注解的组成</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>java.lang.annotation提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><h4 id="Documented-–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。"><a href="#Documented-–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。" class="headerlink" title="@Documented –一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。"></a>@Documented –一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。</h4><h4 id="Retention-–什么时候使用该注解，定义该注解的生命周期"><a href="#Retention-–什么时候使用该注解，定义该注解的生命周期" class="headerlink" title="@Retention –什么时候使用该注解，定义该注解的生命周期"></a>@Retention –什么时候使用该注解，定义该注解的生命周期</h4><ul><li><p>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。例如@Override, @SuppressWarnings都属于这类注解。</p></li><li><p>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</p></li><li><p>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p></li></ul><h4 id="Target-–注解用于什么地方，可用的ElementType参数包括："><a href="#Target-–注解用于什么地方，可用的ElementType参数包括：" class="headerlink" title="@Target –注解用于什么地方，可用的ElementType参数包括："></a>@Target –注解用于什么地方，可用的ElementType参数包括：</h4><ul><li><p>ElementType.CONSTRUCTOR:用于描述构造器</p></li><li><p>ElementType.FIELD:成员变量、对象、属性（包括enum实例）</p></li><li><p>ElementType.LOCAL_VARIABLE:用于描述局部变量</p></li><li><p>ElementType.METHOD:用于描述方法</p></li><li><p>ElementType.PACKAGE:用于描述包</p></li><li><p>ElementType.PARAMETER:用于描述参数</p></li><li><p>ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p></li></ul><h4 id="Inherited-–-定义该注释和子类的关系，或者说是否允许子类继承该注解"><a href="#Inherited-–-定义该注释和子类的关系，或者说是否允许子类继承该注解" class="headerlink" title="@Inherited – 定义该注释和子类的关系，或者说是否允许子类继承该注解"></a>@Inherited – 定义该注释和子类的关系，或者说是否允许子类继承该注解</h4><p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p><h2 id="常见标准的Annotation"><a href="#常见标准的Annotation" class="headerlink" title="常见标准的Annotation"></a>常见标准的Annotation</h2><ul><li><p>Override<br>java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。</p></li><li><p>Deprecated<br>Deprecated也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。</p></li><li><p>SuppressWarnings<br>SuppressWarning不是一个标记类型注解。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。<br>@SuppressWarnings(“unchecked”)</p></li></ul><h2 id="自定义注解遵守原则"><a href="#自定义注解遵守原则" class="headerlink" title="自定义注解遵守原则"></a>自定义注解遵守原则</h2><p>凡事都要有原则的，对猿们来讲，更是要严谨了:yum:，看看这些规则：</p><ul><li><p>Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</p></li><li><p>参数成员只能用public或默认(default)这两个访问权修饰</p></li><li><p>参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组.</p></li><li><p>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法</p></li><li><p>注解也可以没有定义成员, 不过这样注解就没啥用了</p></li></ul><h2 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h2><p>有关相关代码示例，可以点此<a href="https://github.com/producted/annotaion-mybatis-coustom" target="_blank" rel="noopener" title="我的GitHub">GitHub地址</a><br>该工程简单实现了mybatis的@Insert和@select注解的实现，如果有兴趣，你可以做一下@update和@delete的实现</p><h2 id="说说注解在哪使用"><a href="#说说注解在哪使用" class="headerlink" title="说说注解在哪使用"></a>说说注解在哪使用</h2><p>例如签名校验，接口防刷等场景，说白了，类似上一文的<a href="https://uacoding.cn/2019/04/18/java-dealExpForController" title="我的GitHub">springboot对控制层全局异常的处理</a>，个人认为还是结合拦截器或者aop机制来用的场景想对较多吧，当然也有别的用途，暂时没有遇到。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/PORSCHE_GT3RS/article/details/80304701" target="_blank" rel="noopener">https://blog.csdn.net/PORSCHE_GT3RS/article/details/80304701</a></p><p>越码越幸福:sweat_smile:</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot对控制层全局异常的处理</title>
    <link href="/2020/03/01/2019-04-18-java-dealExpForController/"/>
    <url>/2020/03/01/2019-04-18-java-dealExpForController/</url>
    
    <content type="html"><![CDATA[<p>本文将从@controllerAdvice和@ExceptionHandler两个注解到自定义HttpStatus来对控制层的异常进行优雅的处理。</p><a id="more"></a><blockquote><p>说起惭愧，在前不久，我还悻悻然在控制层通过频繁的try catch语句来进行异常处理及对应model返回，这么做当然是没什么错，但频繁写一样的代码属实让人感觉厌烦，于是开始找寻一种可以对异常进行统一异常处理的方式。</p></blockquote><p>本文意在做一套系统性相关整理笔记，方便以后查看。手懒，延迟了个把月。</p><h2 id="几种处理方式"><a href="#几种处理方式" class="headerlink" title="几种处理方式"></a>几种处理方式</h2><h3 id="HandlerExceptionResolver接口"><a href="#HandlerExceptionResolver接口" class="headerlink" title="HandlerExceptionResolver接口"></a>HandlerExceptionResolver接口</h3><p>1.实现HandlerExceptionResolver接口，将实现类作为Spring Bean，这样Spring就能扫描到它并作为全局异常处理器加载</p><p>2.在resolveException中实现异常处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomHandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;<br>        Method method = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span> &amp;&amp; handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>            method = ((HandlerMethod) handler).getMethod();<br>        &#125;<br>        log.error(<span class="hljs-string">"[&#123;&#125;] system error"</span>, method, ex);<br>        ResponseDTO response = ResponseDTO.builder()<br>        .errorCode(ErrorCode.SYSTEM_ERROR)<br>        .build();<br>        <span class="hljs-keyword">byte</span>[] bytes = JSON.toJSONString(response).getBytes(StandardCharsets.UTF_8));<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileCopyUtils.copy(bytes, response.getOutputStream());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">"error"</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从参数上，可以看到，不仅能够拿到发生异常的函数和异常对象，还能够拿到HttpServletResponse对象，从而控制本次请求返回给前端的行为。</p><p>此外，函数还可以返回一个ModelAndView对象，表示渲染一个视图，比方说错误页面，不过，在前后端分离为主流架构的今天，这个很少用了。如果函数返回的视图为空，则表示不需要视图。</p><h3 id="ExceptionHandler局部处理"><a href="#ExceptionHandler局部处理" class="headerlink" title="@ExceptionHandler局部处理"></a>@ExceptionHandler局部处理</h3><p>通过@ExceptionHandler注解可以对当前控制层进行异常处理，当前控制层抛出的异常都会通过该方法来进行返回，这里是一个简单的返回模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/api/test"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient client;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Registration registration;<br><br>    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/addValue"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">adValue</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"a"</span>)</span> Integer a,@<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"b"</span>)</span> Integer b)</span>&#123;<br>        Integer r = a + b;<br>        ServiceInstance instance = serviceInstance();<br>        String result = <span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"/add: Host:"</span>)<br>                .append(instance.getHost())<br>                .append(<span class="hljs-string">", service_id:"</span>)<br>                .append(instance.getServiceId())<br>                .append(<span class="hljs-string">"   result:"</span>)<br>                .append(a + b).toString();<br>        log.info(result);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-comment">//获取当前服务实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServiceInstance <span class="hljs-title">serviceInstance</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;ServiceInstance&gt; instances = client.getInstances(registration.getServiceId());<br>        <span class="hljs-keyword">if</span> (!instances.isEmpty() &amp;&amp; instances.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;<br>                <span class="hljs-keyword">if</span> (instance.getPort() == <span class="hljs-number">7001</span>) &#123;<br>                    <span class="hljs-keyword">return</span> instance;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span> <span class="hljs-title">exceptionHandler</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) </span>&#123;<br>        log.error(<span class="hljs-string">"[&#123;&#125;] system error"</span>, e);<br>        <span class="hljs-keyword">return</span> error(<span class="hljs-string">"出错了！"</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过浏览器来访问一番，比如把参数b写为c，看结果：</p><p><img src="https://uacoding.cn/images/posts/java/allException.png" srcset="/img/loading.gif" alt="java-exception"></p><p>但是这种方法还是存在局促性，我们需要的是对全局controller进行一个异常处理，那么这个时候就需要通过@ControllerAdvice和@ExceptionHandler来结合使用</p><h3 id="通过-ControllerAdvice和-ExceptionHandler来结合使用"><a href="#通过-ControllerAdvice和-ExceptionHandler来结合使用" class="headerlink" title="通过@ControllerAdvice和@ExceptionHandler来结合使用"></a>通过@ControllerAdvice和@ExceptionHandler来结合使用</h3><p>两者结合之后可以对所有控制层就行异常控制，并且可以细粒到具体异常，当然，你也可以定义自定义异常，或者在@ExceptionHandler中放置多个异常，等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler</span>(ParmException<span class="hljs-class">.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-title">ResponseEntity</span> <span class="hljs-title">parmExceptionHandler</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(<span class="hljs-keyword">false</span>, RetCode.PARM_EXCEPTION,e.getMessage(),<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler</span>(JSONException<span class="hljs-class">.<span class="hljs-keyword">class</span>)<br>    <span class="hljs-title">ResponseEntity</span> <span class="hljs-title">jsonExceptionHandler</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(<span class="hljs-keyword">false</span>, RetCode.JSON_EXCEPTION,e.getMessage(),<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>看起来是比较方便简单的，其中ParmException为自定义异常，在方法参数内可以通过Exception来接收并获取到异常信息</p><h3 id="容器中通过HttpStatus定义异常路径，结合两注解"><a href="#容器中通过HttpStatus定义异常路径，结合两注解" class="headerlink" title="容器中通过HttpStatus定义异常路径，结合两注解"></a>容器中通过HttpStatus定义异常路径，结合两注解</h3><p>通过@ControllerAdvice和@ExceptionHandler的确可以对所有controller层进行相对不错的异常控制，但有没有想过这种场景，比如请求404,405,400… 这种异常最好还是通过本系统来进行自定义处理，这样才能提高用户体验。</p><p>那么如何设置呢？上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomErrorServeletFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">ConfigurableWebServerFactory</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//custom error request path</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableWebServerFactory factory)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (HttpStatus e : HttpStatus.values()) &#123;<br>            <span class="hljs-keyword">if</span> (e.value() == HttpStatus.NOT_FOUND.value()) &#123;<br>                factory.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(e,<span class="hljs-string">"/404"</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.value() == HttpStatus.METHOD_NOT_ALLOWED.value()) &#123;<br>                factory.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(e,<span class="hljs-string">"/405"</span>));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.value() != HttpStatus.OK.value()) &#123;<br>                factory.addErrorPages(<span class="hljs-keyword">new</span> ErrorPage(e,<span class="hljs-string">"/500"</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先通过实现WebServerFactoryCustomizer接口中的customize方法来对容器工厂进行配置，可以看到，这里这里我对404,405,500状态码的定义，并设置了一个他们对应的路径，接下来可以自定义这几个路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlagController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;my.git.version:尚未配置&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String gitVersion;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;my.project.buildtime:尚未配置&#125;"</span>)<br>    <span class="hljs-keyword">private</span> String buildTime;<br><br>    <span class="hljs-meta">@RequestMapping</span>(value = &#123;<span class="hljs-string">"/"</span>, <span class="hljs-string">"/version"</span>&#125;)<br>    <span class="hljs-function">Object <span class="hljs-title">version</span><span class="hljs-params">()</span></span>&#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">"Build_Time"</span>,buildTime);<br>        map.put(<span class="hljs-string">"Build_GIT_Version"</span>,gitVersion);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"404"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">notFound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> code = response.getStatus();<br>        response.setStatus(HttpStatus.OK.value());<br>        <span class="hljs-keyword">return</span> error(RetCode.RET_ERROR,code + <span class="hljs-string">"Not Found！"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"405"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">notAllowed</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> code = response.getStatus();<br>        response.setStatus(HttpStatus.OK.value());<br>        <span class="hljs-keyword">return</span> error(RetCode.RET_ERROR,code + <span class="hljs-string">"Not Allowed！"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"500"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">apiError</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> code = response.getStatus();<br>        response.setStatus(HttpStatus.OK.value());<br>        <span class="hljs-comment">//get exception by request</span><br>        Exception e = (Exception) request.getAttribute(<span class="hljs-string">"javax.servlet.error.exception"</span>);<br>        String errorMsg = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            errorMsg = e.getMessage();<br>        &#125;<br>        log.error(<span class="hljs-string">"apiError: &#123;&#125;"</span>,errorMsg);<br>        <span class="hljs-keyword">return</span> error(RetCode.RET_ERROR,code + errorMsg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人认为，任何能够给Controller加切面的机制都能变相的进行统一异常处理。比如：</p><ul><li><p>在拦截器内捕获Controller的异常，做统一异常处理。</p></li><li><p>使用Spring的AOP机制，做统一异常处理。</p></li></ul><p>有没有感觉这种方式让你一看之后感觉可行呢，或许你有更好的处理方式可以通过下方评论区告诉我，不胜感激。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈 SimpleDateFormat 使用的注意事项</title>
    <link href="/2020/03/01/2019-04-11-java-simpledateformat/"/>
    <url>/2020/03/01/2019-04-11-java-simpledateformat/</url>
    
    <content type="html"><![CDATA[<p>来看看SimpleDateFormat的线程安全问题。</p><a id="more"></a><p>程序猿日常与时间打交道是必不可少的，而针对date类型的转换，用的最多的应该就是SimpleDateFormat，然而，此类并不是线程安全的，此文会列出证明其线程不安全和其原因，以及如何解决。</p><h3 id="SimpleDateFormat多线程任务线程不安全"><a href="#SimpleDateFormat多线程任务线程不安全" class="headerlink" title="SimpleDateFormat多线程任务线程不安全"></a>SimpleDateFormat多线程任务线程不安全</h3><p>来看日常使用SimpDateFormat的简单代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpDateFormatTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> sdf.format(date);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parse</span><span class="hljs-params">(String timeStr)</span></span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        <span class="hljs-keyword">try</span> &#123;<br>            date = sdf.parse(timeStr);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> date;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        parse(<span class="hljs-string">"2019-04-11 13:48:08"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单线程情况下没有什么问题，来看多线程任务下的执行情况，将结果打印到控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            service.execute(() -&gt; &#123;<br>                System.out.println(parse(<span class="hljs-string">"2019-04-11 10:48:08"</span>));<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>        service.awaitTermination(<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用20个线程来做String与Date的转换，看看控制台：</p><p><img src="https://uacoding.cn/images/posts/java/simpledateformat.jpg" srcset="/img/loading.gif" alt="java-simpledateformat"></p><p>可以看到，多线程任务执行下转换的日期的不匹配，没毛病吧，再看看format方法多线程环境下的打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Date date = parse(<span class="hljs-string">"1998-04-11 19:00:00"</span>);<br>        Date date1 = parse(<span class="hljs-string">"2019-04-11 10:00:00"</span>);<br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> j = i;<br>            service.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(formatDate(date));<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(formatDate(date1));<br>                &#125;<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>        service.awaitTermination(<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台打印如下：</p><p><img src="https://uacoding.cn/images/posts/java/simpledateformat1.jpg" srcset="/img/loading.gif" alt="java-simpledateformat1"></p><p>你看2019多过分，平白无故比人家1998多打印3次，值大压值小吗？肯定不是，来看看原因。</p><h3 id="为何非线程安全"><a href="#为何非线程安全" class="headerlink" title="为何非线程安全"></a>为何非线程安全</h3><p>因为把SimpleDateFormat定义为静态变量，那么多线程下SimpleDateFormat的实例就会被多个线程共享，B线程会读取到A线程的时间，就会出现时间差异和其它各种问题。SimpleDateFormat和它继承的DateFormat类也不是线程安全的</p><p>来看看SimpleDateFormat的format()方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Called from Format after creating a FieldDelegate</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> StringBuffer <span class="hljs-title">format</span><span class="hljs-params">(Date date, StringBuffer toAppendTo,<br>FieldDelegate delegate)</span> </span>&#123;<br><span class="hljs-comment">// Convert input date to time field list</span><br>calendar.setTime(date);<br><br><span class="hljs-keyword">boolean</span> useDateFormatSymbols = useDateFormatSymbols();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; compiledPattern.length; ) &#123;<br><span class="hljs-keyword">int</span> tag = compiledPattern[i] &gt;&gt;&gt; <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> count = compiledPattern[i++] &amp; <span class="hljs-number">0xff</span>;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">255</span>) &#123;<br>count = compiledPattern[i++] &lt;&lt; <span class="hljs-number">16</span>;<br>count |= compiledPattern[i++];<br>&#125;<br><br><span class="hljs-keyword">switch</span> (tag) &#123;<br><span class="hljs-keyword">case</span> TAG_QUOTE_ASCII_CHAR:<br>toAppendTo.append((<span class="hljs-keyword">char</span>)count);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> TAG_QUOTE_CHARS:<br>toAppendTo.append(compiledPattern, i, count);<br>i += count;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> toAppendTo;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是calendar.setTime(date);，SimpleDateFormat的format方法实际操作的就是Calendar。</p><p>因为声明SimpleDateFormat为static变量，那么它的Calendar变量也就是一个共享变量，可以被多个线程访问。</p><p>假设线程A执行完calendar.setTime(date)，把时间设置成1998-04-11 19:00:00，这时候被挂起，线程B获得CPU执行权。线程B也执行到了calendar.setTime(date)，把时间设置为2019-04-11 10:00:00。线程挂起，线程A继续走，calendar还会被继续使用(subFormat方法)，而这时calendar用的是线程B设置的值了，而这就是引发问题的根源，出现时间不对，线程挂死等等。</p><p>SimpleDateFormat上面给出的注释也明确的指出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">* Date formats are not <span class="hljs-keyword">synchronized</span>.<br>* It is recommended to create separate format instances <span class="hljs-keyword">for</span> each thread.<br>* If multiple threads access a format concurrently, it must be <span class="hljs-keyword">synchronized</span><br>* externally.<br></code></pre></td></tr></table></figure><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li>不在类中用static修饰，直接把SimpleDateFormat放到方法中来创建实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date)</span></span>&#123;<br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>        <span class="hljs-keyword">return</span> sdf.format(date);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parse</span><span class="hljs-params">(String timeStr)</span></span>&#123;<br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        <span class="hljs-keyword">try</span> &#123;<br>            date = sdf.parse(timeStr);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> date;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，仅在需要用到的地方创建一个新的实例，就没有线程安全问题，不过也加重了创建对象的负担，会频繁地创建和销毁对象，效率较低。</p><ul><li>synchronized简单粗暴</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date)</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (sdf) &#123;<br>            <span class="hljs-keyword">return</span> sdf.format(date);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parse</span><span class="hljs-params">(String timeStr)</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (sdf) &#123;<br>            Date date = <span class="hljs-keyword">new</span> Date();<br>            <span class="hljs-keyword">try</span> &#123;<br>                date = sdf.parse(timeStr);<br>            &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> date;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>简单粗暴，synchronized往上一套也可以解决线程安全问题，缺点自然就是并发量大的时候会对性能有影响，线程阻塞。</p><ul><li>ThreadLocal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get().format(date);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parse</span><span class="hljs-params">(String timeStr)</span></span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        <span class="hljs-keyword">try</span> &#123;<br>            date = threadLocal.get().parse(timeStr);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> date;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal会为每一个被其修饰的变量创建一个副本在线程中使用，因此可以解决线程安全问题，缺点是占用内存，当然这点内存对java来讲貌似可以忽略不计。</p><ul><li>基于JDK1.8的DateTimeFormatter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(LocalDateTime date)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> format.format(date);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDateTime <span class="hljs-title">parse</span><span class="hljs-params">(String timeStr)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.parse(timeStr,format);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            service.execute(() -&gt; &#123;<br>                System.out.println(parse(<span class="hljs-string">"2019-04-11 10:52:16"</span>));<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>        service.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br></code></pre></td></tr></table></figure><p>也是《阿里巴巴开发手册》给出的解决方案，运行结果就不贴了，不会出现报错和时间不准确的问题，不过在运用中还是不习惯用DateTimeFormatter，或许下个项目中可以用上呢。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>日期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一份简明的 Markdown 笔记与教程</title>
    <link href="/2020/03/01/2019-03-12-markdown-intro/"/>
    <url>/2020/03/01/2019-03-12-markdown-intro/</url>
    
    <content type="html"><![CDATA[<p>Markdown应该是撰写文本文档的首选。</p><a id="more"></a><p>那么首先我们一起来看一下它的「定义」：</p><blockquote><p>Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。——维基百科</p></blockquote><p>本文档的目的不在于面面俱到地介绍 Markdown，只是作为我对其理解的笔记整理，希望能同时帮助一些对 Markdown 感兴趣的人快速上手，或是作为一个工具，供对其已经有所了解的人在需要时参考。</p><p>接下来请随我一起深入了解这门并不神秘的实用标记语言。</p><p><strong>目录</strong></p><ul><li>[TOC]</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>专注于文字内容；</p></li><li><p>纯文本，易读易写，可以方便地纳入版本控制；</p></li><li><p>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>各类代码托管平台</p><p>  主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。</p></li><li><p>技术社区和写作平台</p><p>  StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记</p></li><li><p>论坛</p><p>  V2EX、光谷社区</p></li></ul><p>个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown 解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用 Markdown 写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。</p><h3 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h3><p>理论上任何一款文本编辑器都能用于编辑 Markdown 文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。</p><ul><li><p>现代编辑器</p><p>  VSCode / Atom</p></li><li><p>传统编辑器</p><p>  Vim / Emacs / Sublime Text / Notepad++</p></li><li><p>IDE 自带编辑器</p><p>  IntelliJ IDEA / Android Studio / WebStorm</p></li><li><p>专用编辑器</p><p>  Ulysses / Mou / Typora / Markpad</p></li><li><p>在线编辑器</p><p>  各种支持 Markdown 的网站都提供了在线编辑器</p></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Markdown：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"># atx-style 一级标题<br><br>## 二级标题<br><br>###### 六级标题<br><br><span class="hljs-section">Setext-style 一级标题<br>===</span><br><br><span class="hljs-section">二级标题<br>---</span><br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><blockquote><h1 id="atx-style-一级标题"><a href="#atx-style-一级标题" class="headerlink" title="atx-style 一级标题"></a>atx-style 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="Setext-style-一级标题"><a href="#Setext-style-一级标题" class="headerlink" title="Setext-style 一级标题"></a>Setext-style 一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>atx-style 一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Setext-style 一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>中间没有空行的连续不断的几行文字被视为一个段落。</p><p><strong>Markdown：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">白日依山尽，<br><br>黄河入海流。<br>（句号后面没空格）<br><br>欲穷千里目，<br><br>更上一层楼。  <br>（句号后面有俩空格）<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p>白日依山尽，</p><p>黄河入海流。<br>（句号后面没空格）</p><p>欲穷千里目，</p><p>更上一层楼。<br>（句号后面有俩空格）</p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>白日依山尽，<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>黄河入海流。<br>（句号后面没有空格）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欲穷千里目，<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  更上一层楼。<br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  （句号后面有俩空格）<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="行内格式"><a href="#行内格式" class="headerlink" title="行内格式"></a>行内格式</h3><p>对段落或者部分文本的强调效果。</p><p><strong>Markdown：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">后面俩字*<span class="hljs-strong">*加黑*</span>*<br><br>后面俩字<span class="hljs-strong">*斜体*</span><br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p>后面俩字<strong>加黑</strong></p><p>后面俩字<em>斜体</em></p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  后面俩字<br>  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>加黑<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  后面俩字<br>  <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>斜体<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p><strong>Markdown：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> 引用块段落一。</span><br><span class="hljs-meta">&gt;</span><br><span class="hljs-meta">&gt;</span><span class="bash"> 引用块段落二。</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt; 内嵌引用块段落一。</span><br><span class="hljs-meta">&gt;</span><br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-comment">### 引用块内的标题</span></span><br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><blockquote><p>引用块段落一。</p><p>引用块段落二。</p><blockquote><p>内嵌引用块段落一。</p></blockquote><h3 id="引用块内的标题"><a href="#引用块内的标题" class="headerlink" title="引用块内的标题"></a>引用块内的标题</h3></blockquote><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用块段落一。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用块段落二。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内嵌引用块段落一。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"引用块内的标题"</span>&gt;</span>引用块内的标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>Markdown 支持行内式链接和引用式链接。</p><p><strong>Markdown：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">行内式 [<span class="hljs-string">博客</span>](<span class="hljs-link">https://uacoding.cn "我的个人博客"</span>) 链接，带 title。<br><br>行内式 [<span class="hljs-string">GitHub</span>](<span class="hljs-link">https://github.com/producted</span>) 链接。<br><br>引用式 [<span class="hljs-string">博客</span>][<span class="hljs-symbol">1</span>] 链接。<br><br>引用式 [<span class="hljs-string">GitHub</span>][<span class="hljs-symbol">2</span>] 链接，带 title。<br><br>[<span class="hljs-symbol">1</span>]: <span class="hljs-link">https://uacoding.cn</span><br>[<span class="hljs-symbol">2</span>]: <span class="hljs-link">https://github.com/producted "我的 GitHub 主页"</span><br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p>行内式 <a href="https://uacoding.cn" title="我的个人博客">博客</a> 链接，带 title。</p><p>行内式 <a href="https://github.com/producted" target="_blank" rel="noopener">GitHub</a> 链接。</p><p>引用式 <a href="https://uacoding.cn">博客</a> 链接。</p><p>引用式 <a href="https://github.com/producted" target="_blank" rel="noopener" title="我的 GitHub 主页">GitHub</a> 链接，带 title。</p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>行内式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://uacoding.cn"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"我的个人博客"</span>&gt;</span>博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接，带 title。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>行内式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://github.com/producted"</span>&gt;</span>GitHub<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://uacoding.cn"</span>&gt;</span>博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://github.com/producted"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"我的 GitHub 主页"</span>&gt;</span>GitHub<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接，带 title。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>在超链接的写法前加一个 <code>!</code>，就是引用图片的方法。</p><p><strong>Markdown：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">Alt text</span>](<span class="hljs-link">https://uacoding.cn/favicon.ico "favicon"</span>)<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p><img src="https://uacoding.cn/favicon.ico" srcset="/img/loading.gif" alt="Alt text" title="favicon"></p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://uacoding.cn/favicon.ico"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Alt text"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"favicon"</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>包括有序列表和无序列表。</p><p><strong>Markdown：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">- </span>苹果<br><span class="hljs-bullet">- </span>葡萄<br><span class="hljs-bullet">- </span>榴莲<br><span class="hljs-bullet"><br>1. </span>苹果<br><span class="hljs-bullet">2. </span>葡萄<br><span class="hljs-bullet">3. </span>榴莲<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><ul><li>苹果</li><li>葡萄</li><li>榴莲</li></ul><ol><li>苹果</li><li>葡萄</li><li>榴莲</li></ol><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>榴莲<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>榴莲<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中无序列表的标记可以使用 <code>+</code>、<code>-</code> 或 <code>*</code>，有序列表前的数字可以是乱序的。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>支持行内代码和代码块。</p><p><strong>Markdown：</strong></p><pre><code>Android 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><p><strong>预览效果：</strong></p><p>Android 里使用 <code>TextUtils</code> 类的 <code>isEmpty</code> 方法来判断字符串是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Android 里使用 <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>TextUtils<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> 类的 <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>isEmpty<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> 方法来判断字符串是否为空。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"highlight highlight-source-java"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pl-k"</span>&gt;</span>if<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> (<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pl-smi"</span>&gt;</span>TextUtils<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pl-k"</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>isEmpty(text)) &#123;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pl-k"</span>&gt;</span>return<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pl-c1"</span>&gt;</span>null<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>;<br>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上例中的语言标记 <code>java</code> 可选填，可用于在编辑器和渲染后的效果里添加语法高亮。</p><p>块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。</p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>使用一个单独行里的三个或以上 <code>*</code>、<code>-</code> 来生产一条水平分割线，它们之间可以有空格。</p><p><strong>Markdown：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">***</span><br><br>-----<br><span class="hljs-bullet"><br>- </span>- -<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><hr><hr><hr><p><strong>对应 HTML：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;hr /&gt;</span><br><br><span class="hljs-section">&lt;hr /&gt;</span><br><br><span class="hljs-section">&lt;hr /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="嵌入-HTML"><a href="#嵌入-HTML" class="headerlink" title="嵌入 HTML"></a>嵌入 HTML</h3><p>Markdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。</p><p>对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。</p><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown：</strong></p><pre><code>| 编号  | 姓名（左） | 年龄（右） | 性别（中） || ----- | :--------  | ---------: | :------:   || 0     | 张三       | 28         | 男         || 1     | 李四       | 29         | 男         |</code></pre><p><strong>预览效果：</strong></p><table><thead><tr><th>编号</th><th align="left">姓名（左）</th><th align="right">年龄（右）</th><th align="center">性别（中）</th></tr></thead><tbody><tr><td>0</td><td align="left">张三</td><td align="right">28</td><td align="center">男</td></tr><tr><td>1</td><td align="left">李四</td><td align="right">29</td><td align="center">男</td></tr></tbody></table><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"left"</span>&gt;</span>姓名（左）<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"right"</span>&gt;</span>年龄（右）<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span>&gt;</span>性别（中）<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"left"</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"right"</span>&gt;</span>28<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"left"</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"right"</span>&gt;</span>29<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"center"</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>在 GitHub / GitLab 里有较好的支持。</p><p><strong>Markdown：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] 洗碗<br><span class="hljs-bullet">- </span>[ ] 清洗油烟机<br><span class="hljs-bullet">- </span>[ ] 拖地<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 洗碗</li><li><input disabled="" type="checkbox"> 清洗油烟机</li><li><input disabled="" type="checkbox"> 拖地</li></ul><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"contains-task-list"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"task-list-item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"task-list-item-checkbox"</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">""</span>&gt;</span> 洗碗<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"task-list-item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"task-list-item-checkbox"</span>&gt;</span> 清洗油烟机<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"task-list-item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"task-list-item-checkbox"</span>&gt;</span> 拖地<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果。</p><p>还可以直接在网页上拖动调整顺序，勾选和取消勾选。</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><strong>Markdown：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">后面三个字打上~~删除线~~。<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p>后面三个字打上<del>删除线</del>。</p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>后面三个字打上<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>删除线<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>自动链接扩展，即：当识别到 URL，或用 <code>&lt;</code>、<code>&gt;</code> 包括的 URL 时，会自动为其生成 <code>a</code> 标签。</p><p><strong>Markdown：</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//github.com</span><br><br><span class="hljs-params">&lt;example@gmail.com&gt;</span><br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><p><a href="mailto:&#101;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#101;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a></p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://github.com"</span>&gt;</span>https://github.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"mailto:example@gmail.com"</span>&gt;</span>example@gmail.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>以 GitHub Pages 为例。</p><p><strong>Markdown：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-meta">:camel:</span> :blush: :smile:<br></code></pre></td></tr></table></figure><p><strong>预览效果：</strong></p><p>:camel: :blush: :smile:</p><p><strong>对应 HTML：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"emoji"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">":camel:"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">":camel:"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"20"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"20"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"emoji"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">":blush:"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">":blush:"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"20"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"20"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"emoji"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">":smile:"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">":smile:"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"20"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"20"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方 JavaScript 插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。</p><h3 id="画流程图和时序图"><a href="#画流程图和时序图" class="headerlink" title="画流程图和时序图"></a>画流程图和时序图</h3><p>有部分网站和编辑器实现了对 Markdown 里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD 的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。</p><p>以我们使用的项目管理工具 TAPD 的在线编辑器为例：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-flowchart.png" srcset="/img/loading.gif" alt="流程图"></p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-seq.png" srcset="/img/loading.gif" alt="时序图"></p><h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><p>仍然以 TAPD 为例：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-math.png" srcset="/img/loading.gif" alt="数学公式"></p><p>应该是利用 JavaScript 支持了 LaTeX 公式语法。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于：</p><ul><li>自动生成 / 更新 Table of Contents</li><li>流程图 / 时序图</li><li>制作幻灯片</li><li>集成 PlantUML / GraphViz 的能力</li><li>导出 HTML / PDF / 电子书</li><li>…</li></ul><p>以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。</p><p>另外可以参考我以前的一篇博客 <a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/" target="_blank" rel="noopener">关于 Markdown 的一些奇技淫巧</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">Markdown: Syntax - DARING FIREBALL</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown - 维基百科</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一道在知乎很火的 Java 题——如何输出 ab</title>
    <link href="/2020/03/01/2019-02-15-java-output/"/>
    <url>/2020/03/01/2019-02-15-java-output/</url>
    
    <content type="html"><![CDATA[<p>这是一个源自知乎的话题，原贴链接：<a href="https://www.zhihu.com/question/50801791" target="_blank" rel="noopener">一道百度的面试题，有大神会嘛？</a></p><a id="more"></a><p>虽然我不是大神，但我也点进去看了一下，思考了一会之后有了一些思路，然后去看其它人的答案的时候果然全都已经被各路大神们先想到并贴出来了，所以我就不去凑热闹写重复答案了，整理一下网友们的智慧在这里自娱自乐好了。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://uacoding.cn/images/posts/java/output-ab.jpg" srcset="/img/loading.gif" alt="java-output-ab"></p><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>作为一个多年前也见过不少笔试题的少年，看到这个题目的第一想法是脑筋急转弯——注入一段逻辑直接改变原 if 结构。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>填入内容 <code>true){System.out.print(&quot;a&quot;);}if(false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>        System.out.print(<span class="hljs-string">"a"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;<br>        System.out.print(<span class="hljs-string">"a"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">"b"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地也可以填入 <code>true){System.out.print(&quot;ab&quot;);return;}if(false</code> 等。</p><p>当初大学时单纯的少年可是很难想出这样的套路的，时间改变了我们啊。</p><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>如果正经遵从题目的原代码结构，那就得想办法构造一段代码，既能输出 <code>a</code>，又能返回 <code>false</code>。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>我也想到能否使用 <code>System.out.print</code> 的返回值来做文章，但奈何并不记得它返回什么，首先让我们复习一下 <code>PrintStream</code> 的 <code>print</code>、<code>println</code> 和 <code>printf</code> 方法的区别：</p><table><thead><tr><th>方法</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>print</td><td>打印一个值或者对象</td><td>void</td></tr><tr><td>println</td><td>打印并换行</td><td>void</td></tr><tr><td>printf</td><td>格式化打印</td><td>PrintStream</td></tr></tbody></table><p>所以适用的是 <code>printf</code>，它的返回值是 <code>PrintStream</code> 类型的 <code>System.out</code>，判它是否为空即可。</p><p>填入内容 <code>System.out.printf(&quot;a&quot;) == null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (System.out.printf(<span class="hljs-string">"a"</span>) == <span class="hljs-keyword">null</span>) &#123;<br>        System.out.print(<span class="hljs-string">"a"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">"b"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经测试填入 <code>System.out.append(&quot;a&quot;) == null</code> 也是可以达到效果的。</p><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>仍然是思路二，但从匿名内部类来作文章。</p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> Object() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.print(<span class="hljs-string">"a"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;.print()) &#123;<br>        System.out.print(<span class="hljs-string">"a"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">"b"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里利用的知识点是匿名内部类可以声明基类没有的新方法并且马上调用。</p><h3 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h3><p>使用 Java 8 里的 lambda 来实现思路二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (((BooleanSupplier)(() -&gt; &#123;System.out.print(<span class="hljs-string">"a"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;)).getAsBoolean()) &#123;<br>        System.out.print(<span class="hljs-string">"a"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">"b"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>严格来讲这个不一定能算作正确答案，因为要增加 <code>import java.util.function.BooleanSupplier;</code>。</p><h2 id="脑洞大开"><a href="#脑洞大开" class="headerlink" title="脑洞大开"></a>脑洞大开</h2><p>讲完严肃的解法，来看看网友 <a href="https://www.zhihu.com/people/qiong-xiao-zi-158" target="_blank" rel="noopener">穷小子</a> 开脑洞的思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    if ( ) &#123;</span><br>        System.out.print(<span class="hljs-string">"a"</span>);<br><span class="hljs-comment">//    &#125; else &#123;</span><br>        System.out.print(<span class="hljs-string">"b"</span>);<br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有特意说明只能在括号里加东西，倒真是个妙计！</p><p>同样看得我一愣一愣的还有 <a href="https://www.zhihu.com/people/caiwei710" target="_blank" rel="noopener">caiwei</a> 同学的答案，他和朋友们发现题目里少写了个大括号（真的），于是我们看到他的朋友老方的解决方案：</p><p><img src="https://uacoding.cn/images/posts/java/add-brace.jpg" srcset="/img/loading.gif" alt="add-brace"></p><p>真是防不胜防啊~不过我喜欢！:+1:</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/50801791/answer/122781965" target="_blank" rel="noopener">RednaxelaFX 的回答</a></li><li><a href="https://www.zhihu.com/question/50801791/answer/122773831" target="_blank" rel="noopener">仓鼠君 的回答</a></li><li><a href="https://www.zhihu.com/question/50801791/answer/122769426" target="_blank" rel="noopener">放开那女孩 的回答</a></li><li><a href="https://www.zhihu.com/question/50801791/answer/122863062" target="_blank" rel="noopener">穷小子 的回答</a></li><li><a href="https://www.zhihu.com/question/50801791/answer/122795854" target="_blank" rel="noopener">caiwei 的回答</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TortoiseSVN 从 GitHub 更新时发生异常</title>
    <link href="/2020/03/01/2019-01-28-svn-exception/"/>
    <url>/2020/03/01/2019-01-28-svn-exception/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 TortoiseSVN 从 GitHub 仓库 Update 时，弹出错误提示对话框：</p><a id="more"></a><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">---------------------------</span><br>Subversion Exception!<br><span class="hljs-comment">---------------------------</span><br>Subversion encountered <span class="hljs-keyword">a</span> serious problem.<br>Please take <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> <span class="hljs-built_in">to</span> report this <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">Subversion</span> <span class="hljs-title">mailing</span> <span class="hljs-title">list</span><br><span class="hljs-keyword">with</span> <span class="hljs-keyword">as</span> much information <span class="hljs-keyword">as</span> possible about what<br>you were trying <span class="hljs-built_in">to</span> <span class="hljs-built_in">do</span>.<br>But please <span class="hljs-keyword">first</span> search <span class="hljs-keyword">the</span> mailing list archives <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> error message<br><span class="hljs-built_in">to</span> avoid reporting <span class="hljs-keyword">the</span> same problem repeatedly.<br>You can find <span class="hljs-keyword">the</span> mailing list archives <span class="hljs-keyword">at</span><br><span class="hljs-keyword">http</span>://subversion.apache.org/mailing-lists.html<br><br>Subversion reported <span class="hljs-keyword">the</span> following<br>(you can copy <span class="hljs-keyword">the</span> content <span class="hljs-keyword">of</span> this dialog<br><span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> clipboard <span class="hljs-keyword">using</span> Ctrl-C):<br><br>In <span class="hljs-built_in">file</span><br> <span class="hljs-string">'D:\Development\SVN\Releases\TortoiseSVN-1.8.11\ext\subversion\subversion\libsvn_wc\update_editor.c'</span><br> <span class="hljs-built_in">line</span> <span class="hljs-number">1550</span>: assertion failed (action == svn_wc_conflict_action_delete)<br><span class="hljs-comment">---------------------------</span><br>确定   <br><span class="hljs-comment">---------------------------</span><br></code></pre></td></tr></table></figure><p>推测发生原因可能是 GitHub 认为本地的目录结构与服务器冲突，因为能看到本地之前 Checkout 出来的一个文件夹显示未纳入版本控制，但是实际上服务器上这个文件夹一直存在在。</p><p>查到在一个 <a href="http://mail-archives.apache.org/mod_mbox/subversion-users/201503.mbox/%3C076701d05e91$234ef3b0$69ecdb10$@qqmail.nl%3E" target="_blank" rel="noopener">邮件列表</a> 里说这是由 GitHub 的实现有点问题导致，但是，也如其它地方能查到的信息一样，并没有给出解决方案。</p><p>经过各种尝试，包括</p><ol><li><p>Clean up</p><p>Clean up 本身能成功，但是再 Update 依然报错。</p></li><li><p>在一个新的文件夹 Checkout</p><p>没有问题。</p></li><li><p>删除可疑文件和文件夹，重新 Update。</p><p>依然报错。</p></li></ol><p>无奈之下试了一下命令行，找到了解决办法。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实很简单，就是使用命令行</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">svn</span> <span class="hljs-string">cleanup</span><br><span class="hljs-attr">svn</span> <span class="hljs-string">update</span><br></code></pre></td></tr></table></figure><p>就可以了，再使用 GUI 的 Update 就不会报错了。</p><p>为啥就好了仍然原因不明。</p><h3 id="最新情况"><a href="#最新情况" class="headerlink" title="最新情况"></a>最新情况</h3><p>后来又出现了一次这样的情况，在命令行 <code>svn update</code> 也不好使了，提示</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">svn: E155010: The <span class="hljs-keyword">node</span> <span class="hljs-title">'a</span>/folder/path/' was not found.<br></code></pre></td></tr></table></figure><p>忍无可忍，切回使用 git。</p>]]></content>
    
    
    <categories>
      
      <category>SVN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>svn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 日期类常用写法小结</title>
    <link href="/2020/03/01/2018-01-23-java-date/"/>
    <url>/2020/03/01/2018-01-23-java-date/</url>
    
    <content type="html"><![CDATA[<p><strong>Date 和 Calendar 转 String</strong></p><p>借助 SimpleDateFormat 类的 format 方法，Calendar.getTime() 返回 Date，最终 Calendar 也是转化为 Date 后转 String。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// see SimpleDateFormat in Java API</span><br>String format = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(format, Locale.US);<br><br><span class="hljs-comment">// Date</span><br>String strDate = sdf.format(<span class="hljs-keyword">new</span> Date());<br><br>Calendar cal = Calendar.getInstance();<br><span class="hljs-comment">// Calendar</span><br>String strCalendar = sdf.format(cal.getTime());<br></code></pre></td></tr></table></figure><p><strong>String 转 Date、Calendar</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String strDate = <span class="hljs-string">"2015-04-04 00:33:00"</span>;<br>Date date = <span class="hljs-keyword">null</span>;<br>Calendar cal = Calendar.getInstance();<br><span class="hljs-keyword">try</span> &#123;<br>    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>, Locale.US);<br>    date = sdf.parse(strDate);<br>    cal.setTime(date);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>设置 Calendar 到某年某月某日</strong></p><p>注意点：</p><ul><li>Month 要设为比实际小 1。</li><li>除显式设置的几个字段外，其它字段之前的值不变；如果不是期待的，可以先调用 clear() 清除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance();<br><span class="hljs-comment">// set to 2015-03-01</span><br>cal.set(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span> - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>复制 Calendar</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar calDst = (Calendar)calSrc.clone();<br></code></pre></td></tr></table></figure><p><strong>求本周、上周、下周的起始时间</strong></p><p>做了一个工具类来处理此事（注意：这里计算的一周是从周一到周日，如果要算周天到周六，把获取本周一时括号里的 +1 去掉）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateCalcUtil</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_PREVIOUS_MONDAY = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_PREVIOUS_SUNDAY = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_THIS_MONDAY = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_THIS_SUNDAY = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_NEXT_MONDAY = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_NEXT_SUNDAY = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">calc</span><span class="hljs-params">(Calendar base, <span class="hljs-keyword">int</span> calcType)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取这一周开始基准</span><br>        <span class="hljs-keyword">int</span> min = base.getActualMinimum(Calendar.DAY_OF_WEEK);<br>        <span class="hljs-comment">// 获取当天在这一周内天数</span><br>        <span class="hljs-keyword">int</span> current = base.get(Calendar.DAY_OF_WEEK);<br>        Calendar calendar = (Calendar)base.clone();<br><br>        <span class="hljs-comment">// 获取本周一</span><br>        <span class="hljs-keyword">int</span> nCount = (current == min) ? -<span class="hljs-number">6</span> : (min - current + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">switch</span> (calcType) &#123;<br>            <span class="hljs-keyword">case</span> GET_PREVIOUS_MONDAY:<br>                nCount -= <span class="hljs-number">7</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_PREVIOUS_SUNDAY:<br>                nCount -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_THIS_MONDAY:<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_THIS_SUNDAY:<br>                nCount += <span class="hljs-number">6</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_NEXT_MONDAY:<br>                nCount += <span class="hljs-number">7</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_NEXT_SUNDAY:<br>                nCount += <span class="hljs-number">13</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        calendar.add(Calendar.DAY_OF_WEEK, nCount);<br><br>        <span class="hljs-keyword">return</span> calendar;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 今天</span><br>Calendar base = Calendar.getInstance();<br><br><span class="hljs-comment">// 本周</span><br>Calendar thisMonday = DateCalcUtil.calc(base, DateCalcUtil.GET_THIS_MONDAY);<br>Calendar thisSunday = DateCalcUtil.calc(base, DateCalcUtil.GET_THIS_SUNDAY);<br><br><span class="hljs-comment">// 下周</span><br>Calendar nextMonday = DateCalcUtil.calc(base, DateCalcUtil.GET_NEXT_MONDAY);<br>Calendar nextSunday = DateCalcUtil.calc(base, DateCalcUtil.GET_NEXT_SUNDAY);<br><br><span class="hljs-comment">// 上周</span><br>Calendar previousMonday = DateCalcUtil.calc(base, DateCalcUtil.GET_PREVIOUS_MONDAY);<br>Calendar previousSunday = DateCalcUtil.calc(base, DateCalcUtil.GET_PREVIOUS_SUNDAY);<br></code></pre></td></tr></table></figure><p><strong>获取两个日期相差天数</strong></p><p>注意点：</p><ul><li>getTimeInMillis 返回的是 0 时区时间，所以有可能把你的时间加减了几个小时，造成计算天数有误，这种方法必须考虑时区因素再运算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> daysCount1 = (calendar1.getTimeInMillis() + calendar1.get(Calendar.ZONE_OFFSET))<br>    / (<span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">long</span> daysCount2 = (calendar2.getTimeInMillis() + calendar2.get(Calendar.ZONE_OFFSET))<br>    / (<span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">long</span> dayDiffer = daysCount1 - daysCount2;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>日期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/01/hello-world/"/>
    <url>/2020/03/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
